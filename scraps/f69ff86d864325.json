{
  "title": "APoSD読書メモ",
  "closed": true,
  "archived": false,
  "created_at": "2022-06-24",
  "comments": [
    {
      "author": "wooootack",
      "created_at": "2022-06-24",
      "body_markdown": "### Preface\n\n- 質の高い練習が大事というのは分かるが、同じ練習量をこなした時に個人差はあると思う\n- これは意見書だ！というスタンスが個人的に好き\n- こうすべきだ！という本はあまり好きじゃないので\n- プログラミング技術≠設計スキル？\n  - プログラミング技術の中に設計スキルがあっても良い気もするけどな\n- 設計スキルを言語化する＝DDDとか？\n- 徹底的なレビューをするっていう学生の取り組み、若干プラハチャレンジ感ある？"
    },
    {
      "author": "wooootack",
      "created_at": "2022-06-27",
      "body_markdown": "## Chapter1: Introduction\n\n### 要約\n\nソフトウェアはどんどん複雑になっていくが、良い設計を覚えてれば単純化できる\nただし、色々なテクニックや原則には限界があるので、やりすぎは良くない\nそして物理的なシステムとは違って、ソフトウェアは非常に柔軟なので、最初に設計して終わりではない\n常に考えて試して、より良い設計にしていこう！！！\n\n### メモ\n\n- プログラムはシステムの成長と共に機能が増え、依存関係が増え、より複雑になる\n  - それこそ業務システムとかクソ複雑になるから仕方ないところもある気がする\n  - モデリングで不要なものを削ぎ落とすのと同じで、不要な複雑さや依存関係も削ぎ落としたい\n- 複雑さの増加を止めるのは難しいが、良い設計を学んで立ち向かうことができる\n- ソフトウェアの柔軟さがウォーターフォールではうまくいかない要因になってしまっている\n  - 逆に無理やりウォーターフォールに当てはめて柔軟さを失ったシステムもいっぱいあるな〜と思った\n  - そしてそのシステムの価値はどんどん減っていく\n- 設計に終わりはなく、複雑さを軽減するために常に考え続けることが必要\n- 色々なルールを紹介するが、すべてのルールに例外があり、「原則には限界がある」と学ぶべき",
      "body_updated_at": "2022-06-27"
    },
    {
      "author": "wooootack",
      "created_at": "2022-06-29",
      "body_markdown": "## Chapter2: The Nature of Complexity\n\n## Chapter2.1: Complexity defined\n\n### 要約\n\n時間が足りず断念\n\n### 翻訳\n\n- この章では、以下の問題を解決していく\n  - そもそも複雑さとは何なのか？\n  - 不必要に複雑であるかどうかは、どのようにして見分けられるのか？\n  - なぜ複雑化してしまうのか？\n- **筆者は複雑さを認識するのも重要な設計スキルと言っている**\n  - 問題を事前に発見できるから\n  - 選択肢の中から適切なものを選択できるから\n- シンプルな設計を実践するより、シンプルかどうかを判断する方が最初は簡単\n  - まずはそれを認識できるようになろう\n  - 設計が複雑に見えたら、別のアプローチで試してみる\n    - よりシンプルな設計にできた\n      - **このやり方の方がシンプルだな？このやり方は複雑になるかも？という傾向がわかってくる**\n- 本書における「複雑さ」は実用的な方法で定義している\n  - 理解しにくく、修正しにくいなら、それは複雑\n  - 理解するのも修正するのも簡単であれば、それは単純\n- **複雑さはシステムの規模や機能とは必ずしも関係がなく、開発者がある時点で経験する**\n  - 大規模システムでも理解や修正が簡単ならそれは単純\n- あるシステムに非常に複雑な部分がいくつかあっても、その部分はほとんど触る必要がないなら、システム全体の複雑さにはあまり影響を及ぼさない\n  - *分かりやすいインターフェースを提供することが大事そう*\n- 複雑さの式はよく分かってないが「理解や修正に時間がかかる=複雑というのがあの式の意味があっている？」\n- 複雑さは書き手より読み手の方が気付きやすい\n  - 他の人が複雑だと思ったら、なぜ複雑に見えるのか聞いてみる価値がある\n  - 自分にとっても他人にとっても単純なコードを書くべき",
      "body_updated_at": "2022-06-29"
    },
    {
      "author": "wooootack",
      "created_at": "2022-06-29",
      "body_markdown": "## Chapter2.2: Symptons of complexity\n\n### 複雑さがもたらす影響について\n\n一般的に以下の3つ\n\n1. **Change amplification**\n    - ある変更をする際に、単純な変更のはずなのに、多くの箇所でコードの修正が必要になってしまう状態。\n      - ただし、変更箇所さえ明確にできていれば、その全てを漏れなく変更することで、最悪なんとかできる。\n      - *早すぎる共通化？みたいな考え方もあるから、ここはバランス取らないとダメだなと思った。特にフロントエンドって共通化のタイミング難しくない？*\n2. **Cognitive load**\n    - ある変更をする際に、開発者が知っておくべき知識が多すぎる（認知負荷が高い）状態。\n      - 人間の脳には処理能力の限界があるので、見落としや忘れが発生するリスクが高くなる。\n      - ただし、知っておくべき知識を明確にできていれば、メモを取ったりとか何らかの工夫をすることで、最悪なんとかできる。\n    - コードの行数が少ないからといって、単純もしくは認知負荷が低いとは限らない。\n      - 数行のコードでアプリケーションを書けるFWがあったとしても、それを理解するのは難しい。\n      - 時にはより多くのコード行を必要とするアプローチの方が認知負荷を下げることができる。\n        - *最近Scala書いててこれはよく思う*\n3. **Unkown unknowns**\n    - ある変更をする際に、「何をするべきなのか？」「どういう情報が必要なのか？」というそもそものところが分からない状態。\n    - これが3つの中で最も最悪な状態。\n      - 「何か問題があるんだろう」とは分かる。\n      - ただし実際に何が問題なのか、それによって何が起きるのかは、やってみないと分からない。\n      - 全てのコードを読んで理解すれば、解決することはできるかもしれないが、どの規模であってもそれは現実的ではない。\n    - *こうなる前にどこかで止められなかったのか？日々の積み重ねしかない？*\n\n### その影響を受けないようにするために\n\nシステムを常にシンプルに保てるように設計することが大事。\nシンプルに設計できていれば、以下のような状態になる。\n\n1. ある変更において、修正が必要となるコードが少ない。\n2. 既存のコードがどのように動作し、変更を加えるために何が必要かをすぐに理解できる。\n3. 何をすべきが素早く推測でき、その推測が正しいと自信を持てる。\n\n--- \n## 18章に続く...！\n---\n\n### 疑問\n\nP.18の下から4行目は何が言いたいんだろう？\nコードを全部読んでもダメ！なぜなら...という文脈でこれを言っているような気がするが、文書化とかどう関係してくるのか？\n\n> Even this may not be sufficient, because a change may depend on a subtle design decision that was never documented.\n>\n> なぜなら、変更は文書化されていない微妙な設計上の判断に依存する場合があるからです。\n",
      "body_updated_at": "2022-06-29"
    },
    {
      "author": "wooootack",
      "created_at": "2022-06-29",
      "body_markdown": "## Chapter2.3: Causes of complexity\n\n### メモ\n- 複雑さの原因は「依存性」「不明瞭性」\n  - 依存性\n    - あるコードを単独で理解、修正ができない => 依存関係がある\n    - 依存関係をなくすことは不可能だし、意図的に注入している部分もある\n    - 依存関係をなくすのではなく、依存数を減らし、残った依存関係をできるだけ単純で明白なものにすることが大事\n  -  不明瞭性\n      - 一般的な変数名を使ったことで、何を示しているのが分からない => 不明瞭\n      - 知らないうちに依存関係が生まれてしまう => 不明瞭\n      - 同じ変数名なのに異なる使われ方をしている => 不明瞭\n      - 多くはドキュメントが不足していることが不明瞭性につながる\n        - システムが単純なら必要なドキュメントは減っていく\n        - 大規模なドキュメントが必要な場合は、危険な匂いがする\n        - 不明瞭さを減らすには、やはり単純な設計をすることが大事\n  - 依存性と不明瞭性を組み合わせると、先に紹介した3つの複雑性につながる\n    - 依存性は `Change amplification`と`Cognitive load`を、不明瞭さは `Unkown unkowns`と`Cognitive load`をうむ\n- 依存性と不明瞭性を最小化する設計技法が見つかれば、複雑性を低減することができる！それは複雑さを軽減することにもつながる",
      "body_updated_at": "2022-06-29"
    },
    {
      "author": "wooootack",
      "created_at": "2022-06-30",
      "body_markdown": "## Chapter2.4: Complexity is incremental\n\n## メモ\n- 複雑さは単一の破壊的なエラーによって引き起こされるわけではなく、蓄積されていくものである\n  - 1つの依存関係が全体の保守性に大きな影響を与えることはない\n  - 何百、何千という小さな依存関係や不明瞭さが時間と共に蓄積されるから\n- 蓄積されていくという性質が、複雑さを抑制することを難しくしている\n  - 現在の変更でもたらされる少しの複雑さは大したことではないと自分に言い聞かせるのは簡単\n  - これを全員がやると、複雑さは一気に蓄積される\n- 一度蓄積された複雑さを解消するのは難しい\n  - 一部だけを修正しても、それ自体は大きな変化をもたらさない\n- 複雑さの増大を抑えるには「ゼロ・トレランス」哲学を採用する必要がある。これは3章で説明される。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-06-30",
      "body_markdown": "## Chapter2.5: Coclution\n\n## メモ\n- 2章のまとめ\n  - 複雑なコードを変更することは困難であり、リスクも高い"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-04",
      "body_markdown": "## Chapter3: Working Code Isn't Enough\n\n## メモ\n- 優れたソフトウェア設計の最も重要な要素の1つは、プログラミングタスクに取り組む際の考え方である。\n- 多くの組織では、機能をできるだけ早く動作させることに焦点を当てた戦術的な考え方を推奨している。\n- ただし良い設計をするためには、より戦略的なアプローチを取る必要がある。\n- 長期的には戦術的アプローチよりも、戦略的アプローチの方がより良いソフトウェアを作成できる。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-04",
      "body_markdown": "## Chapter3.1: Tactical programming\n\n## メモ\n- ほとんどのプログラマーは、戦術的プログラミングと呼んでいる考え方でソフトウェア開発をしている\n  - 戦術的アプローチでは、何かを動作させることに集中する\n  - 一見すると、理にかなっているように見えるが、これでは良いシステム設計をすることはほとんど不可能である\n- 戦術的プログラミングの問題点は、タスクを早く終わらせることに集中しすぎて、将来の見通しを立てられていないことである。\n  - 最適な設計を探さず、早く動かすことにフォーカスする。\n  - *複雑さが蓄積していっているといえる*\n  - どこかで後悔するタイミングがくるが、リファクタリングをして直近の速度を落とすことを避けて、簡単なパッチを当てることを優先する\n  - すると、さらにパッチが必要になる。\n  - こうなると、もうちょっとのリファクタリングではどうにもならないので、ひたすら戦術的にプログラミングをするしかなくなってしまう\n- ほとんどのソフトウェア開発組織には、戦術的プログラミングを極限まで追求する人が1人はいる\n  - 簡単な機能を実装する場合は、すぐに機能を完成させるが、破壊の痕跡を残す\n  - 他のエンジニアはそれらの後始末をしなければならないのである\n\n"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-05",
      "body_markdown": "## Chapter3.2 Strategic Programming\n\n- 戦略的プログラミングとは何か？\n  - 優れたソフトウェア設計者になるための第一歩は、**コードを書くだけでは不十分であることを認識すること**\n  - 最も重要なのは**システムの長期的な構造**である\n  - 動く「だけ」のコードではなく、将来の拡張を容易にするようなコードを書く\n- 戦略的プログラミングを行うためには？\n  - 投資マインドが必要\n  - 最速の道を進むのではなく、設計を改善するための時間を投資する\n    - *質の良いコードを書くことが最速で作ることに繋がる、みたいなスライドがあったはず。t_wadaさんの質とスピードだったような*\n  - 具体的に何をすべきか？\n    - 最初に思いついたアイデアを実行するのではなく、いくつかの代替案を試して、最も良いものを選ぶ\n    - 将来的に変更する必要がある場合を想定して、それが容易になるような設計を心がける\n    - **良いドキュメントを書くこと**\n      - *良いドキュメントとはなんだろう*\n  - ただしこれらの先行投資が必ずしもあっているとは限らない\n    - 時間が経てばその間違いは現れてくる\n    - そのときに無視したり、その場しのぎの対応をせず、時間をかけて修正する",
      "body_updated_at": "2022-07-05"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-05",
      "body_markdown": "## Chapter3.3 How much to invest?\n\n- では具体的にどれくらい先行投資をするべきか？\n  - システム全体を設計するような莫大な先行投資は効果が低い\n    - ウォーターフォールを指している\n  - 理想的な設計は、そのシステムで経験を積んでいく内に見えてくる\n    - そこで継続的にたくさん小さな投資をすることが大事である\n    - *ここはアジャイル開発まわりと言っていることが似てそう*\n  - 筆者のおすすめは、開発時間の10%~20%\n    - スケジュールに大きな影響を与えない程度に小さい\n    - 長期的に大きな利益を生むには十分な大きさ\n    - 初期段階でこの10%~20%を払えば、後で回収できる\n- 戦術的プログラミングをやったらどうなる？\n  - 戦略的プログラミングと逆のことが起きる\n    - 最初は早いがすぐに遅くなっていく\n      - *割と懐疑的ではある。質の良いコード書ける人はそもそも速いジャンって感じ*\n    - 未来から時間を借りているようなものと例えている\n      - 金融債務と同様に返済額は借りた額を上回る\n      - そして金融債務と違い、技術負債は完全に返済されることはほとんどない\n      - *ここのたとえ話面白いな〜とか思った*"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-08",
      "body_markdown": "## Chapter4: Module Shoud Be Deep\n\n- ソフトウェアの複雑性を管理するためには、複雑さをどこか1箇所に隠蔽すること\n- このアプローチはモジュール設計と呼ばれる"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-08",
      "body_markdown": "## Chapter 4.1: Modular Design\n\n- 独立したモジュールの集まりに分解する\n- 理想は各モジュールが完全に独立している状態\n  - とはいえこれは実現不可能\n  - モジュールはそれぞれのメソッドや関数を呼び合って動く\n- じゃあモジュール間の依存関係を最小に抑えよう\n  - インターフェースと実装を分ける\n  - インターフェースは何をするかを書き、どうやるかは書かない\n  - そのモジュールを開発する人は実装を知っている必要があるが、使うだけの人はインターフェースだけ知っていれば良い\n- インターフェースが実装よりも単純であることが良い\n  - 他のモジュールに与える複雑さを最低限に止めることができる\n  - インターフェースさえ変わらなければ他のモジュールは影響を受けない"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-11",
      "body_markdown": "## Chapter4.3 Abstractions\n\n- 抽象化とは、ある実態を簡略化して重要でない部分を省略したもの\n- モジュールプログラミングでは、各モジュールはインターフェースを使って抽象化を実現する\n  - 実装の詳細はモジュールの抽象化の観点からは重要ではないので、省く\n    - ただし本当に重要でない細部でなければ、抽象化から省くことはできない\n  - 抽象化には2つの失敗がある\n    - 重要ではない細部を含んでしまう\n    - 詳細が省かれてしまっている\n  - 抽象化をする際には、何か重要なのかを理解し、その情報を最小限にする設計を模索すること\n- 例\n  - ファイルシステム\n    - 使う側が、ストレージの詳細を気にする必要はない\n    - ただし、ストレージにいつ書き込むかは使う側が指定する必要がある\n  - 電子レンジ、自動車\n    - 難しいメカニズムを知らなくても使えるようになっている"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-11",
      "body_markdown": "## Chapter4.4 Deep Modules\n\n- 良いモジュールとは、強力な機能を持ちながら、シンプルなインターフェースを持つもの\n  - 深いモジュールと呼ばれる\n- インターフェースがシンプルなので、複雑さを隠蔽できており、ユーザーが使うコストが低い\n- 強力な機能があるため、そのモジュールは大きな利益をもたらす\n- 低いコストで高い利益を！\n- UnixのI/Oなんかはとても良いモジュールらしい\n  - 現代的に実現するには、何十万行ものコードが必要\n  - そのうちの多くは、Unixファイルシステムの実装によって処理される\n  - そのためプログラマが気にするところではない\n  - UnixのI/Oは進化してきたが、5つの基本的なカーネルコールは変わっていない\n- GCもディープモジュールと言える\n  - システムに追加すると、オブジェクトを解放するためのインターフェースが不要になる"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-11",
      "body_markdown": "## Chapter4.5 Shallow Module\n\n- 提供する機能に比べてインターフェースが複雑なモジュール\n  - 機能がインターフェースを通して全て分かってしまいそうなものとか\n    - そもそも抽象化できていない\n    - 逆に複雑になってしまっていることもある\n  - インターフェースを挟むことで複雑さを軽減できているか？を考える\n- 浅いモジュールは、内部動作を学ぶ必要はなくても、インターフェースを学ぶコストがかかることで、あまり意味をなさなくなってしまう"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-11",
      "body_markdown": "## Chapter 4.6 Classitis\n\n### まとめ\n\nクラスを小さくすることに意義を唱えている章？\n\n- 一般的な教え\n  - クラスは小さくあるべきで、深くあるべきではない\n  - 関数やメソッドについても同じ\n  - これを突き詰めていくアプローチを、**クラス炎**と呼んでいる\n  - クラスは良いものであり、多い方が良いと脳死で考えてしまう\n- 何が起こるのか\n  - 個々のクラスは単純になるが、システム全体で見ると複雑さは増大する\n  - たくさんのクラスを組み合わせて使わなければならなくなる\n  - それぞれのクラスは独自のインターフェースを持つので、それらを理解しなければならない\n  - 定型分が増え、冗長になる\n\n### 感想\n\n- 意見の割れそうな章だなと思った\n- 個人的には、クラスは小さくあるべきとは思わない。\n- ただしクラスの中で細かくメソッドに切り出したりするのはありだと思う。\n- 肥大化したクラスがあったとしても、内部的に別クラスに切り出すような別の責務や機能がない限り、コード量で分けることはする必要はないと思う",
      "body_updated_at": "2022-07-11"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-11",
      "body_markdown": "## Chapter 4.7 Example Java and Unix I/O\n\n### まとめ\n\nJavaを良くない例、Unixを良い例として、前章の具体例を出してきた。\n\n- Java\n  - クラス炎が顕著に見られる\n    - 例えば、ファイルを開いてシリアライズされたオブジェクトを読むために、3つのオブジェクトが必要\n      - FileStream ... 初歩的なI/Oのみを提供する\n      - BufferInputStream ... FileInputStreamにバッファリングを提供する\n      - ObjectInputStream ... シリアライズされたオブジェクトの読み書きを提供する\n  - Java開発者はきっと、常にバッファリングが必要とは限らないのだから、これで良いと主張する\n  - しかし、インターフェースは**一般的なケースを単純化するよう設計するべき**\n    - バッファリングを必要とするI/Oの方が一般的\n    - バッファリングが不要なケースは、それを指定できるような仕組みを用意しておく\n      - コンストラクタを分けたり、メソッドを介して設定できるようにしたり\n- Unixは一般的なケースを単純化できている\n  - シーケンシャルI/Oが最も一般的であることを認識して、それをデフォルトの動作としている\n  - ランダムアクセスしたい場合は、seekシステムコール（？）を使ってくれ\n  - インターフェースに多くの機能があっても、ほとんどの開発者がそのうちのいくつかを意識すればよいだけなら、そのインターフェースの複雑さは、よく使われるものだけで考えても良いと主張している\n\n### 感想\n\n- 確かにJavaのI/Oはイケてない。\n  - それぞれのクラスが利用者にとってあまり価値のあるものになっていない。\n  - 単独で使えないのがあんまり良くない気がする。\n  - 内部的に分かれていても良いが、使う側にその内部事情を察してもらっているようなもの。\n- インターフェースに多くの機能があっても、よく使われるものだけを複雑さの基準にしても良いみたいなことを言っている\n  - これってJSのArrayとかも該当するのだろうか\n  - 機能は多いけど、map, filterとか人気どころだけなら簡単に使える",
      "body_updated_at": "2022-07-11"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-11",
      "body_markdown": "## Chapter 4.8 Conclusion\n\n### まとめ\n\n- モジュールのインターフェースを実装から切り離すことで、実装の複雑さを隠蔽できる\n- モジュールを使う人は、インターフェースだけを理解すれば良い\n- モジュール設計をする際の重要な点は、一般的なユースケースに対して簡単なインターフェースを持ちつつも、重要な機能を提供できるようにすること（深いモジュール）\n\n\n### 感想\n\n- 深いモジュール、浅いモジュールの話がインパクトデカいが、ここで筆者が伝えたかったのは、どちらかというと良いインターフェースを提供しなさいってことだったのかなと思った\n- 良いインターフェースを提供するためには、誰が何のために使うモジュールなのかをよく考える必要があるなと思った\n- 何でも汎用的なインターフェースを考えるのではなく、パッケージプライベートとかで使える人を限定するとか、可視性も重要なファクターっぽいな〜とか思ったりした",
      "body_updated_at": "2022-07-11"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-13",
      "body_markdown": "5章はついにどうやって深いモジュールを作るのか？というあたりに突入しそう\n\n## Chapter 5.1 Information hiding\n\n- 深いモジュールを実現するための最も重要な技術の一つに情報隠蔽（カプセル化）がある\n  - カプセル化された知識はモジュールの実装には現れるが、インターフェースには現れない\n- 情報隠蔽には2つの方法がある\n  - 1つめ、モジュールのインターフェースを単純化する\n    - モジュールの機能をよりシンプルで抽象的に表現し、詳細を隠す\n    - モジュール使用者の認知負荷が下がる\n  - 2つ目、システムを進化しやすくする\n    - うまくカプセル化できていれば、外部への依存がないので、修正等はそのモジュールだけに影響する\n- privateな変数やメソッドにすることと、情報の隠蔽は同じではない\n  - もし仮にゲッターやセッターを定義してしまったら、パブリックと何も変わらない\n- 最も良い例は、モジュール内で情報を完全に隠蔽して、ユーザーから何も見えないようにすること\n  - とはいえ部分的な情報隠蔽も価値はある\n    - 特定の状況でしか使われないような機能は、一般的な使用例では見えないように別メソッドでアクセスするようにすれば、ほとんどは隠蔽できる\n\n\n## 感想\n\n- 言ってることはただのカプセル化？\n- ドメインモデルで例えると、ドメイン知識を漏らさずに使えるようなインターフェースを定義しろ！って感じかな\n"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-13",
      "body_markdown": "## Chapter 5.2 Information leakage\n\n- 情報隠蔽の反対は情報漏洩である\n- 情報漏洩は、ある設計上の決定が複数のモジュールに反映されることで発生する\n  - モジュール間に依存関係が生まれ、関係するすべてのモジュールに変更が必要になる\n- インターフェースに情報が反映されている場合、それは情報漏洩と定義され、インターフェースがシンプルであるほど情報隠蔽率は高くなる\n- ただしインターフェースに情報がなくても情報は漏れる\n  - 内部的に、とあるフォーマットに依存している、ファイルを操作するクラス\n  - フォーマットが変わったら、すべてのクラスに変更が必要\n- 情報漏洩を防ぐには、知識を1つのモジュールに閉じ込めるように思考することが大事\n  - クラスが小さいなら統一してしまっても良いかもしれない\n  - 依存している情報だけを取り出したクラスを切り出しても良いかもしれない\n    - ただし、これは詳細な情報を隠蔽できるようなインターフェースが見つかった時だけにした方が良い\n    - 結局インターフェースを通じてほとんどの情報が外部に出るなら、それは漏洩していることと変わらない"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-15",
      "body_markdown": "## Chapter 5.3 Temporal Decomposition\n\n- 情報漏洩の1つに時分割と呼ばれる設計スタイルがある\n  - *時間的凝集の話か？*\n  - ファイルを読み、変更し、書き出すというアプリを考える\n    - 多分3つのクラスに分かれる（読み、変更、書き）\n    - こうすると、読み書きの両方がファイルフォーマットに依存する\n      - じゃあ2つを統合すればよい\n  - 順序はアプリにおいて重要なので、どこかでは必ず現れる\n    - モジュール構造には順番を極力意識させない方が良い（それこそ何度読んでも同じ動きをすることが望ましいのかもしれない）\n"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-15",
      "body_markdown": "## Chapter 5.4 Example HTTP Server\n\n- HTTPプロトコルの実装を例に考えてみる\n- WebサーバーがHTTPリクエストを受信して、レスポンスを送信することを容易にするために、1つまたは複数のクラスを実装するような課題があった\n\n具体例は5.5からっぽい"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-17",
      "body_markdown": "## Chapter 5.5 too many classes\n\n### 紹介事例\n\n多数の浅いクラスに分割してしまい、クラス間において情報漏洩が発生した\n\n### 具体的にどんな感じか\n\nHTTPリクエストを受けとるために、2つのクラスを使っていた\n\n- 1つ目のクラス ... ネットワーク接続からリクエストを文字列に読み取る\n- 2つ目のクラス ... その文字列の解析\n\n### 何が問題なのか\n\n#### モジュール間において時間的な依存関係が生まれている。\n \n1つ目のクラスを呼んでからじゃないと2つ目のクラスは呼べない。\n\n### モジュール間に重複したコードが生まれている。\nContent-Lengthヘッダーはリクエストボディの長さを指定するので、リクエストの合計の長さを計算するためには、ヘッダーを解析する必要がある。\n ネットワークからリクエストを文字列に変換する場合にも、文字列からボディだけを取得する場合にも、この文字数が必要となる。\n\n### どうするべきだったのか\n\n#### このケースなら、1つのクラスに統一するのが良かった。\n\n特定の機能に関連するコードを1つにまとめることができる。\nより良い情報隠蔽ができ、シンプルなインターフェースを提供できた。\n\n### 補足\n\nただし、大きすぎるクラスが良いという訳ではない。\n9章では、どういう時にクラスを分けることが理にかなっているのかを説明するとのこと。",
      "body_updated_at": "2022-07-17"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-17",
      "body_markdown": "## Chapter 5.6 HTTP Parameter Handling\n\n### 紹介事例\n\nリクエストのパラメータを取得する際に、情報隠蔽ができていなかった。\n\n### 前提\n\n- サーバーはリクエスト情報からパラメーターを取得する必要がある\n  - クエリパラメーターから取得するかもしれないし、ボディから取得するかもしれない\n- 各パラメーターには、名前と値がある\n- 値は、空白や記号をエンコードしていることが多いが、サーバーはエンコードされていない形式を必要とする\n\n### ほとんどの学生がやっていた、良かった例\n\n- サーバーは、パラメータがクエリパラメーターとボディのどちらで指定されたか気にしないことにして、それらのパラメータを1つにマージするようにした\n- エンコードしていることを内部に隠蔽した\n \n### ほとんどの学生がやっていた、悪かった例\n\n- HTTPRequest型のクラスを作って、キーと値のマップを返すだけのメソッドを作っていた\n \n### 何が問題なのか\n\n- 内部情報が完全に漏洩していて、もし内部実装が変わったらすべての使用箇所も修正が必要になる\n- Mapの参照を受け取るので、そのMapを変更したら...？？？というのも呼び出し側の考慮する点となってしまう\n\n### どうするべきだったのか\n\n- getParameterメソッドとgetIntParameterメソッドをHTTPRequestクラスに作る\n- 引数で受けたキーの値を返すだけで、内部情報は隠蔽できる\n- 存在しないキーだったら例外を投げるようになっている",
      "body_updated_at": "2022-07-17"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-17",
      "body_markdown": "## Chapter 5.7 Defaults in HTTP Response\n\n### 紹介事例\n\nHTTPレスポンスオブジェクトを例に、デフォルト値の重要さを説明\n\n### 具体的にどんな感じか\n\n- レスポンスオブジェクトを作成する際に、HTTPプロトコルのバージョンを明示的に指定するようなインターフェースにしていた\n- レスポンスの送信時刻を表すDateヘッダも（多分）明示的に指定するようになっていた\n\n### 何が問題なのか\n\n- レスポンスとリクエストのバージョンは必ず一致すべきで、それを呼び出し側が知っていること自体が情報漏洩している\n- 一般的なユースケースにおいて、Dateヘッダを呼び出し元が指定する必要はない\n\n### どうするべきだったのか\n\n- どちらもデフォルト値をHTTPクラス側が設定するべき\n- 仮にオーバーライドしたい時があるのなら、そういう特殊なメソッドを作っておけば良い\n  - その場合に呼び出し側がバージョンや時刻を知っていることは情報漏洩ではない\n\n### 補足\n\n可能な限り、クラスは明示的に要求されなくても正しいことをするべき。\n最高の機能とは、その存在を意識することなく手に入れられるもの。\n\n- 26PのJava I/Oは、これを満たしていない\n  - ファイルI/Oのバッファリングは普遍的に望ましく、明示的な要求は不要で、存在を意識する必要すらなかった",
      "body_updated_at": "2022-07-17"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-21",
      "body_markdown": "## Chapter 6.2\n\n- 多数の浅いメソッドを持ってしまい、それぞれが1つのユーザーインターフェースの操作にしか適さない\n  - これはそんなにおかしいだろうか？\n  - 例えば、Repositoryにfind/findByIdの2つを定義するより、find1個にして引数で制御しろって話か？\n  - それともfindByHogeUsecase/findByFugaUsecaseみたいな定義をするなって話？"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-22",
      "body_markdown": "## Chapter 6.3, 6.4\n\n- 昨日話したことがそのまま書いてあった気がする\n- アプリに特化せずに、テキストクラスが何をすべきなのかでメソッドを作ろうって話"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-27",
      "body_markdown": "## Chapter 7\n\n- 上下の層から異なる抽象化を提供する？\n  - ファイルシステム\n    - 最上位層は、抽象的なファイルを扱う\n    - 次の下位層は、固定サイズのディスクブロックのメモリ内キャッシュを実装\n    - 最下層はデバイスドライバで、二時記憶装置とメモリ間でブロックを移動させる\n  - ネットワークプロトコルも同じような感じ\n- 似たような抽象化を持つ層が上下で並んでいるのは赤信号\n\n\n## Chapter 7.1\n\n- 隣接する層の抽象度が似ていると、パススルーメソッドという形で問題になることが多い\n  - 呼び出すメソッドとシグネチャが類似または同一の別のメソッドを呼び出す以外に、ほぼ何もしない\n  - クラスの分け方がうまくいっていない証拠らしい\n  - スルーさせるのではなく、その機能を持つクラスがインターフェースも持っておくべき\n  - パススルーメソッドを見かけたら、それぞれのクラスがどの機能と抽象化を担っているのか考える\n  - 解決策は3つある\n    - 下位クラスを上位クラスから直接呼ぶようにする。レイヤーを飛ばすイメージ。\n    - **クラス間で機能を再分配する、これは何が嬉しいのかよくわからん**\n    - 最終手段として、クラスを統合する\n- 学生は、クラス間でメソッドを移動することで、パススルーメソッドを排除し、3つのクラスを2つにしたらしい\n\n"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-28",
      "body_markdown": "## Chapter 7.2\n\n- 同じシグネチャを持つメソッドがあることは、必ずしも悪ではない\n  - パススルーメソッドのように、新しい機能を提供しないから悪い\n  - ディスパッチャは同じシグネチャを持つことが多いが、内部的にどのメソッドを呼ぶか？を判断するという新しい機能を提供しているので、悪ではない\n  - OSのディスクドライバも、複数のディスクをサポートできるように抽象的なインターフェースを持ち、ドライバがそれを実装するので、同じシグネチャが生まれる\n  - しかし、これはそれぞれが独立していて、別の機能であり、悪ではない\n\n---\n\n## Chapter 7.3\n\n- ラッパークラスは使いすぎると、浅いクラスが生まれがちになる\n  - 多くのパススルーメソッドを持つ可能性がある\n- ラッパークラスを導入する前に以下のことを自問する\n  - ラッパークラスではなく、直接元のクラスに追加はできないか？\n    - 新機能が汎用的か元のクラスと関連があるか元のクラスがほとんどのケースで新機能が必要な時に使える\n  - 新機能が特定のユースケースに特化しているなら、それはユースケースがわでなんとかできないか\n  - 新機能を新しいラッパークラスではなく、他のラッパークラスにマージできないか\n  - そもそもそれはラッパークラスではないとダメか？別のクラスでも良いんではないか？*今なら委譲かな？*\n- ラッパーが有効な場面もある\n  - インターフェースを変更できない外部システムを使っていて、それを使うアプリケーションでは別のインターフェースに準拠しなければならない時\n    - *腐敗防止層とかのこと？*"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-28",
      "body_markdown": "## Chapter 7.4 Interface versus implementation\n\n- クラスのインターフェースと、内部実装は異なるべきである\n  - これらがほぼ同じなら、うまく抽象化できておらず、浅いクラスになっている\n- 6章の例\n  - テキストクラスの内部実装が行単位で文字列を扱うようになっていた\n  - インターフェースも行単位を意識したものになっていた\n  - ユーザーが欲しいのは、insert/deleteのようなインターフェース\n  - 内部実装をうまくカプセル化して、そのクラスをより深くしていく\n  - どんなインターフェースが欲しいのか？を考えて、内部実装を意識せず使えるようにする\n\n---\n\n## Chapter 7.5 Pass-through variables\n\n- パススルー変数とは、長い一連のメソッドを通して渡される変数のこと（多くのメソッドが意識する必要がある変数？）\n  - 高レベルメソッドから低レベルメソッドにひたすら渡されていくだけの変数\n  - 中間メソッドは、その変数をただ受け渡すだけなのに、存在を認識せざるを得ない\n  - 新しい変数が出現した場合に、変数を関連する全てのメソッドの渡していくため、変更量が増える\n- **しかしこれを排除するのは難しい**\n- 紹介されている解決案①\n  - 共有オブジェクトを定義して、最上位メソッドがそのオブジェクトを作成、最低位オブジェクトはそのオブジェクトがあれば使う\n  - *この共有オブジェクトどこで作られてるの？となりそう。コンストラクタでDIっぽくやるならアリだと思う。そうすれば使う側の存在チェックいらないし。*\n- 紹介されている解決案②\n  - グローバル変数を使う\n  - 当然ながらあまりおすすめはされていない\n- 紹介されている解決案③\n  - コンテキストオブジェクトの導入\n  - 筆者はこれが多いらしい\n  - ReactのuseContextと同じっぽい感じがする（あれはシステムのインスタンスごとに1個ではないと思うが）\n  - コンテキストはおそらく多くの場所で必要とされるので、パススルー変数になりやすい\n  - コンテキストの参照をシステムの主要なオブジェクトのほとんどに保存しておくことでこれを避ける\n    - あたかも既にそこにコンテキストがあるのだ...！かのように扱える\n  - コンテキストのデメリット\n    - その変数何？どこで使われてるの？みたいなものが生まれてしまう可能性がある\n      - ルールを作りましょうという割とフワッとした対応が書かれていた\n      - *複数箇所で使われる場合限定+例外的に必ずコメントを書くとかどうだろう*\n    - マルチスレッド環境で問題が起こるかもしれない\n      - イミュータブルにすれば問題ない\n  - **それでも筆者はコンテキストより良い解決策をまだ見つけていないとのこと**\n\n---\n\n## Chapter 7.6 Conclusion\n\n- インターフェース、引数、関数、クラス等を追加するたびに開発者は学習が必要で、複雑さは増す\n- これらを追加したことで増えた複雑さ以上の利益をもたらすためには、これらを追加していない時に存在していた複雑さを取り除くことが必要\n  - そうでないなら無駄な複雑化になっている\n  - 例えば機能を追加してもカプセル化することで複雑さを軽減できている\n- パススルー変数は、機能は追加されないのに複雑さだけを増してしまっている\n\n---",
      "body_updated_at": "2022-07-28"
    },
    {
      "author": "wooootack",
      "created_at": "2022-07-31",
      "body_markdown": "## Chapter 8\n\n- モジュールのユーザーにその複雑さを処理させるべきか、モジュールの内部でその複雑さを処理すべきか？\n  - その複雑さがモジュールが提供する機能に関するなら、モジュール内部で隠蔽すべき\n  - 開発者 < ユーザーなので、開発者が苦しむ方がマシ\n  - **モジュールにとって重要なのは、シンプルな実装よりもシンプルなインターフェイス**\n\n## Chapter 8.1\n\n- 例の紹介\n  - テキストクラスが行単位のインターフェースを公開してた時は、使う側が行を必要なくても行を意識する必要があって複雑だった\n  - テキストクラスが行を意識しないインターフェースを公開してた時は、使う側は簡単だがテキストクラスの実装は難しくなった\n\n## Chapter 8.2\n\n- 脳死でなんでもパラメータで設定できるようにするのは良くない\n  - 大体完璧な数値をユーザーが設定するのは無理\n  - 動的に計算したほうが良いケースもあるし、固定だと古くなりがち\n  - ユーザーもしくは上位モジュールが、ここよりも最適な設定値を導けるのか？を考える\n  - もしパラメータを公開するなら、デフォルト値は設定しておくべき\n  - 理想はパラメータをなくして、各モジュールが最も最適な設定をする\n\n"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-01",
      "body_markdown": "## Chapter 9\n\n- 結合するか分離するかを決めるときは何を指針とすべきか？\n  - **システム全体としての複雑さを減らし、モジュール性を向上させる**\n- システムを多数の小さな構成要素に分割するのが最適？\n  - 構成要素が小さければ小さいほど、個々の構成要素はより単純になる可能性が高い。\n  - **細分化するという行為は，細分化する前には存在しなかった複雑性をさらに生み出す**. \n  - ここの見分けが重要\n- 2つのコードが関連していることを示すいくつかの指標\n  - 両方のコードが特定の文書の構文（型かな？）に依存する\n  - 両者は双方向に一緒に使用されることがある。\n \n\n"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-04",
      "body_markdown": "## Chapter 9.7 メソッドを分けるか結合するか\n\n- 長いメソッドは短いメソッドより理解しにくい**傾向がある**ので、多くの人はメソッドを分割する正当な理由として長さだけを主張する\n  - 長さそのものがメソッドを分割する良い理由になることはほとんどない\n  - メソッドを分割するとインターフェースが増え複雑さが増す\n- 長いメソッドが常に悪いわけではない\n  - 20行のコードブロックが５個あるメソッドを例に挙げる\n  - ブロックが独立している場合、ブロックごとに理解ができるので、メソッドを分けてもあまりメリットはない\n  - ブロックの相互作用が複雑な場合、一度にすべてのコードを見ることができるようにブロックをまとめるべき\n  - 長いメソッドであっても、シンプルなシグネチャで読みやすければ問題ない\n  - **それは深いメソッドなのだから**\n- メソッド設計で最も重要なことは、きれいな抽象化。\n  - メソッドは1つのことを完全に行うべき\n  - シンプルなインターフェースながらも深い機能を提供するべき\n  - この性質を備えているメソッドならば、長さは問題ではない\n- メソッドを分割することが意味を持つのは、全体で見たときにより綺麗な抽象化をもたらす場合のみ\n  - 長いメソッド（親メソッド）をサブタスク（子メソッド）に切り出す\n    - 親メソッドは子メソッドの実装は読まなくてよいし、子メソッドは親メソッドのことを意識する必要がない\n    - 子メソッドが比較的汎用的な場合に有効\n    - ただし親メソッドと子メソッドのどちらも理解しなければならないような場合は、よい分割にはなっていない\n  - メソッドを2つに分割する\n    - 密接に関連しない複数のことを行おうとしたために、過度に複雑なインターフェースになっている場合に意味がある\n    - 分解したメソッドそれぞれは、元のメソッドの一部の機能を持つ\n    - 必ず分割後のインターフェースのほうがシンプルになるような分割をする\n    - ほとんどの呼び出し元が、分割後のうちどちらかだけを呼ぶようなら良い分割\n    - 逆にほとんどの呼び出し元がセットで呼んでいるなら、それは複雑になっているだけかもしれない\n    - 新しいメソッドが元のメソッドより汎用的で、何をするかに焦点を絞ることができているなら良い兆候\n  - 呼び出し元が分割したメソッドのそれぞれを使って、その間で状態をやり取りして、みたいな状態は分割しないほうが良い\n    - 結局呼び出し側にとっては複雑さが増している\n\n---\n\n## Chapter 9.8 クリーンコードは別の意見らしい\n\n- Robert Martinは、関数は長さだけで分割されるべきであると主張している\n  - 筆者も短い関数のほうが理解しやすいという点には同意をしている\n  - とはいえ、数十行の関数と十行程度の関数では、そんなに影響ないのでは？と\n  - それよりも関数を分割して、システム全体の複雑さが軽減されるのか？を考えるべき\n- 「1つの大きな関数を読む」のと「いくつかの短い関数を読んで、それらがどのように連携しているのかを理解する」の、どちらが簡単か？\n  - 機能を小さくしすぎると、それぞれの機能の独立性が失われ、一緒に読んで理解しなければならないような結合した機能になる\n  - これなら、大きな関数を残して、一箇所にまとめたほうが良い\n- まずは深い関数を作る。次に読みやすいように短くする。\n- 長さのために深さを犠牲にしてはならない。\n\n---\n\n## Chapter 9.9 まとめ\n\n- モジュールの分割や結合は、複雑さを考慮して決定する必要がある\n- 情報隠蔽性が最も高く、依存関係が最も少なく、インターフェースが最も深い構造を選ぶ\n",
      "body_updated_at": "2022-08-04"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-22",
      "body_markdown": "## 13.6\n\n実装コメントとは、メソッドが内部でどのように動作するかを読者が理解するのを助けるためにメソッドの内部に表示されるコメントです。\nほとんどのメソッドはとても短くてシンプルなので、実装コメントは必要ありません。コードとインターフェースのコメントがあれば、メソッドがどのように動作するかは簡単にわかります。\n実装コメントの主な目的は、コードが何をしているのかを読者が理解するのを助けることです（どのようにそれを行うかは関係ありません）。\nコードが何をしようとしているのかが読者に伝われば、そのコードがどのように動作するのかを理解するのは通常簡単です。\n短いメソッドでは、コードはただひとつのことしか行いません。それはすでにインターフェイスコメントで説明されているので、実装コメントは必要ありません。\n長いメソッドには、メソッド全体のタスクの一部として異なることを行ういくつかのコードブロックがあります。\nそれぞれの主要なブロックの前にコメントを追加して、そのブロックが何をするのかについて高レベルの（より抽象的な）説明を提供します。\n以下はその例です。\n\n```\n// フェーズ 1：アクティブな RPC をスキャンして、完了したものがあるかどうかを確認します。\n```\n\nこのようなコメントは、読者が重要な部分を見つけるためにコードをナビゲートするのに役立ちます。\nループの場合、各反復で何が起こるかを説明するコメントをループの前に記述すると便利です。\n\n```\n// 以下のループの各反復は、リクエストメッセージから1つのリクエストを抽出し、対応するオブジェクトをインクリメントし、レスポンスメッセージにレスポンスを追加する。\n```\n\nこのコメントは、より抽象的で直感的なレベルでループを説明していることに 注意してください。リクエストメッセージからどのようにリクエストが抽出され、 どのようにオブジェクトがインクリメントされるかの詳細には触れていません。\nループコメントが必要なのは、ループが何をしているのかが明らかでない、長いループやより複雑なループの場合だけです。多くのループは短くて単純なので、その動作はすでに明らかです。\n実装コメントは、コードが何を行っているかを説明するだけでなく、その理由を説明するのにも有効です。\nもし、コードを読んでもわからないようなトリッキーな部分があれば、それを文書化する必要があります。\nたとえば、バグフィックスで目的がはっきりしないコードを追加する必要がある場合、なぜそのコードが必要なのかを説明するコメントを追加します。\n問題を記述したよくできたバグレポートがある場合のバグフィックスでは、 その詳細をすべて繰り返すのではなく、バグ追跡データベースの問題を コメントで参照できます 。\n開発者はバグデータベースを見れば、より詳細な情報を得ることができます (これはコメントで重複を避ける例で、第16章で説明します)。\n長いメソッドの場合、最も重要なローカル変数のいくつかについてコメントを書いておくと便利です。\nしかし、ほとんどのローカル変数は、良い名前であればドキュメントを書く必要はありません。\nある変数のすべての用途が数行でわかるようになっていれば、 通常はコメントなしでもその変数の目的を理解することは容易です。\nこの場合、読者にコードを読ませて変数の意味を理解してもらっても問題ありません。\nしかし、その変数がコードの大きなスパンで使用されている場合は、変数を説明するコメントを追加することを検討する必要があります。\n変数を説明するときは、その変数がコードの中でどのように操作されているかではなく、その変数が何を表しているかに注目しましょう。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-22",
      "body_markdown": "## 13.7\n\n完璧な世界では、すべての重要な設計上の決定は、単一のクラスの中にカプセル化されています。\n残念ながら、実際のシステムでは、複数のクラスに影響を与える設計上の決定が必然的に発生します。\n例えば、ネットワークプロトコルの設計は、送信側と受信側の両方に影響し、これらは異なる場所で実装されるかもしれません。\nクロスモジュールの設計は複雑で微妙なことが多く、多くのバグの原因になっています。\nクロスモジュールのドキュメントの最大の課題は、開発者が自然に発見できるような場所にドキュメントを配置することを見つけることです。\n時には、そのようなドキュメントを置くための明らかな中心的な場所があることがあります。\n例えば、RAMCloudストレージシステムはStatus値を定義しており、これは各リクエストによって返され、成功または失敗を表します。\n新しいエラー条件に対するStatusを追加するには、多くの異なるファイルを修正する必要があります（あるファイルはStatusの値を例外にマッピングし、別のファイルは各Statusに対して人間が読めるメッセージを提供するなど）。\n幸いなことに、新しいステータス値を追加する際に開発者が行かなければならない明らかな場所が一つあります。それは、status enum の宣言です。\nこのことを利用して、その列挙型の中にコメントを追加し、他の変更しなければならない場所をすべて特定するようにしました。\n\n```\n注：新しいステータス値を追加する場合、以下の追加更新が必要である。\n\n(1) STATUS_MAX_VALUEを、定義された最大のステータス値と等しい値を持つように変更し、その定義がリストの最後のものであることを確認する。STATUS_MAX_VALUEは主にテストのために使用される。\n(2) Status.ccのmessagesとsymbolsのテーブルに新しいエントリーを追加する。\n(3) ClientException.hに新しい例外クラスを追加する。\n(4) ClientException::ThrowException に、ステータス値からステータス固有の ClientException サブクラスへのマッピングのための新しい「case」を追加する。\n(5) Javaバインディングで、例外用の静的クラスをClientException.javaに追加する。\n(6) ClientException.javaに、例外を投げるためのステータスに関するケースを追加する。\n(7) Status java で例外を Status 列挙型に追加し、Status がそのステータスコードに対応する正しい位置にあることを確認する。\n```\n\n新しいステータス値は既存のリストの最後に追加されるので、コメントも一番見やすい末尾に配置されます。\n残念ながら、多くの場合、モジュール間のドキュメントを置くための明らかな中心的場所がありません。\nRAMCloudストレージの例では、ゾンビサーバー（システムがクラッシュしたと思っていても、実際にはまだ稼働しているサーバー）に対処するためのコードがありました。\nゾンビサーバーを無力化するには、いくつかの異なるモジュールのコードが必要で、これらのコード片はすべて互いに依存しています。\nどのコードも、明らかにドキュメントを置くべき中心的な場所とは言えません。\n一つの可能性は、それに依存している各場所にドキュメントの一部を複製することです。\nしかし、これでは不便です。また、システムの進化に伴って、このようなドキュメントを最新の状態に保つことは困難です。\nまた、ドキュメントを必要な場所に置くこともできますが、この場合、開発者がドキュメントを見ることはまずありませんし、どこで探せばいいのかもわかりません。\nを知ることはないでしょう。\n私は最近、モジュール間の問題をdesignNotesと呼ばれる中心的なファイルに文書化するアプローチを試みています。\nこのファイルは、主要なトピックごとに、明確にラベル付けされたセクションに分けられています。\n例えば、このファイルからの抜粋は次のとおりです。\n\n```\nゾンビ（Zombies\n\nゾンビは、クラスタの他のサーバーから死んだとみなされるサーバーです。サーバーに保存されているデータはすべて復旧され、他のサーバーで管理されます。\nしかし、ゾンビが実際には死んでいない場合（例えば、しばらくの間、他のサーバーから切断されていた場合）、2種類の不整合が発生する可能性があります。\n* ゾンビサーバーは、代替サーバーが引き継いだ後、読み込み要求を出してはいけません。\nゾンビサーバーは、代替サーバーが引き継いだ後、読み取り要求を処理してはなりません。\nそうでなければ、代替サーバーが受け付けた書き込みを反映しない、古いデータを返す可能性がある。\n* ゾンビサーバーは、代替サーバーが復旧中にログの再生を開始したら、書き込み要求を受け付けてはならない。\nゾンビサーバーは、代替サーバーがリカバリ中にログの再生を開始した後は、書き込み要求を受け付けてはいけません。\nRAMCloudは、ゾンビを無力化するために2つの技術を使用しています。まず1つ目。\n```\n\nそして、これらの問題のいずれかに関連するコードの部分には、designNotesファイルを参照する短いコメントが記載されています。\nこの方法では、ドキュメントは1部だけで、開発者が必要なときに比較的簡単に見つけることができます。\nしかし、この方法では、ドキュメントに依存するコードの近くにドキュメントがないため、システムの進化に伴ってドキュメントを最新に保つことが難しくなる可能性があるという欠点があります。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-22",
      "body_markdown": "## 13.8\n\nコメントの目的は、システムの構造や動作が読者にとって明らかであるようにすることであり、読者は必要な情報を素早く見つけ、動作に確信を持ってシステムの改造を行うことができます。\nこの情報の一部は、読者にとってすでに明白な方法でコードに表現することができますが、コードから容易に推測できない情報もかなりあります。\nこの情報を補うのがコメントです。\nコメントは、コードからではわからないことを記述するというルールに従うとき、「わかる」というのは、あなたのコードを初めて読む人（あなたではない）の視点からのものです。\nコメントを書くときは、読む人の気持ちになって、その人が知るべき重要なことは何かを考えてみてください。\nもし、あなたのコードがレビューを受けているときに、レビュアーから「自明ではない」と言われたとしても、反論してはいけません。反論する代わりに、彼らが何を分かりにくいと思ったのかを理解し、より良いコメントやより良いコードで、それを明確にできるかどうか試してみてください。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-22",
      "body_markdown": "## 13.9\n\nIndexLookupクラスを使用するために、開発者は以下の各情報を知る必要があるか。\n\n1.IndexLookup クラスがインデックスやオブジェクトを保持するサーバに送信するメッセージの形式。\n\nいいえ：これは実装の詳細であり、クラス内に隠されているはずです。\n\n2.特定のオブジェクトが目的の範囲にあるかどうかを判断するために使用する比較関数 (比較は、整数、浮動小数点数、文字列のどれで行うのか?)。\n\nはい: クラスのユーザーはこの情報を知る必要があります。\n\n3.サーバーにインデックスを格納するために使用されるデータ構造。\n\nいいえ: この情報はサーバにカプセル化されるべきです。IndexLookup の実装でさえも、この情報を知る必要はありません。\n\n4.IndexLookupは、異なるサーバに対して同時に複数のリクエストを発行するかどうか。\n\n可能性があります。もし IndexLookup がパフォーマンスを向上させるために特別な技術を使用しているのであれば、 ドキュメントはそれに関するハイレベルな情報を提供すべきです。\n\n5.サーバーのクラッシュを処理するメカニズム。\n\nNo: RAMCloud はサーバーのクラッシュから自動的に回復するので、クラッシュはアプリケーションレベルのソフトウェアからは見えません。したがって、IndexLookup のインターフェースドキュメントでクラッシュに言及する必要はありません。したがって、IndexLookup のインターフェイス ドキュメントでクラッシュについて説明する必要はありません。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-23",
      "body_markdown": "## 14 名称の選択\n\n変数やメソッドなどの名前を決めることは、ソフトウェア設計において最も神経を使うことの一つです。\n良い名前は、コードを理解しやすくするために、文書化されます。\nまた、他の文書の必要性を減らし、エラーの発見を容易にします。\n逆に、名前の付け方が悪いと、コードが複雑になり、曖昧さや誤解が生じ、バグが発生する可能性があります。\n名前の選択は、「複雑さは漸進的である」という原則の一例です。\n特定の変数に、可能な限り最高の名前ではなく、平凡な名前を選択しても、おそらくシステム全体の複雑さにはあまり影響を与えないでしょう。\nしかし、ソフトウェア・システムには何千もの変数があります。これらすべてに良い名前を選択することは、複雑さと管理性に大きな影響を与えます。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-23",
      "body_markdown": "## 14.1 例：悪い名前はバグの原因になる\n\n時には、たった一つの不適切な変数名が重大な結果をもたらすことがあります。\n私がこれまで修正した中で最も困難なバグは、名前の選択が不適切だったために発生しました。\n1980年代後半から1990年代前半にかけて、私は大学院生と一緒にSpriteという分散型オペレーティングシステムを作りました。\nある時、ファイルの日付が消えることがあることに気づきました。ユーザーによってファイルが変更されていないにもかかわらず、データブロックの1つが突然すべて0になるのです。\nこの問題はあまり頻繁に起こるものではないので、追跡するのは非常に困難でした。\n何人かの大学院生がバグを見つけようとしましたが、なかなか進展せず、結局あきらめました。\nしかし、私は未解決のバグは個人的に許しがたい侮辱だと考えているので、追跡することにした。\n半年かかって、ようやくバグを発見し、修正することができました。\n問題は実に単純であった（ほとんどのバグがそうであるように、一度わかってしまえば）。\nファイルシステムのコードでは、blokという変数名を2つの異なる目的で使っていたのです。\nある状況では、ブロックはディスク上の物理的なブロック番号を参照し、別の状況では、ブロックはファイル内の論理的なブロック番号を参照していました。\nしかし、あるとき、論理ブロック番号を含むブロック変数が、物理ブロック番号が必要な場面で誤って使われてしまったのです。\nこのバグを追跡している間、私を含む何人かがその不具合のあるコードを読み返したが、問題には気づかなかった。\n変数ブロックが物理ブロック番号として使われているのを見たとき、反射的にそれが本当に物理ブロック番号として保持されていると思い込んでしまったのだ。\nその結果、特定のステートメントで破損が発生していることがわかり、名前によるメンタルブロックを乗り越えて、その値がどこから来たかを正確にチェックできるようになるまでには、長いインストルメンテーションのプロセスが必要でした。\nもし、fileBlockとdiskBlockのように、異なる種類のブロックに対して異なる変数名を使用していれば、このようなエラーは発生しなかったと思われます。\nさらに良いのは、2つの異なる種類のブロックに別々の型を定義して、それらが入れ替わることがないようにすることです。\n残念ながら、ほとんどの開発者は名前についてあまり時間をかけて考えていません。\n思いついた名前をそのまま使う傾向があります。\n例えば、blockはディスク上の物理ブロックとファイル内の論理ブロックの両方にかなり近い名前であり、確かにひどい名前ではありません。\nそれでも、微妙なバグを追跡するために膨大な時間を費やすことになりました。\nこのように、「まあまあ近い」という程度の名前に甘んじてはいけないのです。\n少し時間をかけて、正確で曖昧さのない、直感的に理解できる素晴らしい名前を選びましょう。\nこのような配慮はすぐに報われ、時間が経つにつれて、良い名前を素早く選ぶことができるようになるはずです。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-24",
      "body_markdown": "## 14.2 イメージを作る\n\n名前を選ぶときの目標は、読み手の心の中に、名付けられたものの性質についてイメージを作り出すことである。\n良い名前は、その実体が何であるか、そしてそれと同じくらい重要なのは、それが何でないかということについて、多くの情報を伝えるものである。\nある名前を考えるとき、自分に問いかけてみてください。「もし誰かがこの名前を単独で見た場合、その宣言も文書も、この名前を使ったコードも見ないで、この名前が何を指しているのかをどれだけ詳しく推測できるだろうか？\nより明確なイメージを描ける他の名前はないだろうか？\nもちろん、1つの名前に込められる情報量には限界がある。2〜3語以上の単語を含む名前は扱いにくくなる。\nそのため、いかにしてその実体の最も重要な側面をとらえることができるかということになります。\n名称は抽象化の一形態であり、より複雑な基本的実体について考えるための簡便な方法を提供するものである。\n他の抽象化と同様に、最も優れた名称とは、基本的な実体について最も重要なことに注意を向け、重要でない細部を省略したものである。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-26",
      "body_markdown": "## 14.4 名前を一貫して使用する \n\n良い名前の2つ目の重要な特性は、一貫性です。\nどんなプログラムでも、何度も繰り返し使用される変数があります。例えば、ファイル・システムではブロック番号を繰り返し操作します。\nこのような一般的な使い方をする場合、その用途に合った名前を選び、どこでも同じ名前を使うようにします。\n例えば、ファイルシステムでは、ファイル内のブロックのインデックスを保持するために、常にfileBlockを使用することができます。\n一度、ある文脈でその名前を見た読者は、その知識を再利用し、別の文脈でその名前を見たときに即座に推測することができるのです。\n一貫性には3つの要件があります。第一に、与えられた目的には常に共通の名前を使うこと、第二に、与えられた目的以外には決して共通の名前を使わないこと、第三に、その名前を持つすべての変数が同じ動作をするほど目的が狭いものであることを確認することです。\nこの3番目の要件が破られたのが、冒頭のファイルシステムのバグである。\nファイルシステムでは、2つの異なる動作（ファイルブロックとディスクブロック）を持つ変数にブロックを使用していました。このため、変数の意味について誤った思い込みが生じ、結果としてバグが発生したのです。\n時には、同じ一般的な種類のものを参照する複数の変数が必要になることがあります。例えば、ファイルデータをコピーするメソッドでは、コピー元とコピー先の2つのブロック番号が必要になります。\nこのような場合、各変数には共通の名前を使用し、srcFileBlockやdstFileBlockのように区別するための接頭語を追加します。\nループもまた、一貫した命名が有効な分野です。\nループ変数にasiやjといった名前を使う場合、最も外側のループでは必ずiを使い、ネストされたループではjを使うようにします。\nこれにより、読者は与えられた名前を見たときに、そのコードで何が起こっているのかを即座に（安全に）推測することができます。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-26",
      "body_markdown": "## 14.5 余分な単語を避ける \n\n名前の中のすべての単語は、有用な情報を提供する必要があります。変数の意味を明確にするのに役立たない単語は、単に混乱を招くだけです (たとえば、行の折り返しが多くなってしまう可能性があります)。\nよくある間違いは、fileObject のような名前に field や object などの一般名詞を付けてしまうことです。この場合、Objectという単語はおそらく有用な情報を提供しないので（Objectでないファイルも存在するのか）、名前から省略する必要があります。\nコーディングスタイルによっては、ファイルオブジェクトへのポインタである変数に fileptr というように、名前に型情報を含めるものもあります。\n極端な例として、マイクロソフトで長年C言語のプログラミングに使われていたハンガリー記法があります。\nハンガリー記法では、すべての変数名に、その完全な型を示す接頭辞が付きます。\n例えば、arrugNumberListという名前は、この変数が符号なし8ビット整数の配列であることを意味する。私は過去に変数名に型情報を入れたことがありますが、もうお勧めしません。\n最近のIDEでは、変数名から宣言まで簡単にクリックできる（あるいはIDEが自動的に型情報を表示する）ので、変数名にこの情報を含める必要はないのです。\nもうひとつの例として、クラスのインスタンス変数がクラス名と重複している場合があります。\n文脈から、この変数がFileクラスの一部であることは明らかなので、クラス名を変数名に含めても、何の役にも立ちません。\nクラスが異なるタイプの複数のブロックを含んでいる場合を除き、変数ブロックに名前を付けるだけです。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-26",
      "body_markdown": "## 14.6 異なる意見 囲碁スタイルガイド \n\n名前の付け方について、誰もが私の意見に賛同しているわけではありません。\nGo言語の開発者の中には、名前は非常に短く、しばしば1文字だけであるべきだと主張する人がいます。\nGoの名前の選択に関するプレゼンテーションで、Andrew Gerrandは、「長い名前は、コードが何をするのかわからない」と述べています。\n彼は、1文字の変数名を使用した次のようなコード サンプルを紹介しています。\n\n```go\nサンプルコード\n```\n\nという一文字の変数名を使ったコードサンプルを紹介し、長い名前を使った次のバージョンよりも読みやすいと主張しています。\n\n```go\nサンプルコード\n```\n\n個人的には、2番目のバージョンは最初のバージョンよりも読みにくいとは感じません。どちらかというと、nよりも名前の数の方が、変数の挙動を知る上で少し良い手がかりになります。\n最初のバージョンでは、nが何を意味するのかを理解するためにコードを読み進めることになりましたが、2番目のバージョンではその必要性を感じません。\nしかし、nがカウントを参照するためにシステム全体で一貫して使用されていれば（それ以外には使用されていなければ）、おそらく他の開発者にとっても短い名前は明確なものになるはずです。\nGoの文化では、chはcharacterまたはchannel、aはdata、differenceまたはdistanceなど、複数の異なるものに対して同じ短縮名を使用することが推奨されています。\n私には、このような曖昧な名前は、ブロックの例と同じように、混乱やエラーを引き起こす可能性があります。\nつまり、読みやすさを決めるのは書き手ではなく、読み手なのだ。\n短い変数名でコードを書いて、それを読んだ人がわかりやすいと思えば、それでいいのです。\nもし、あなたのコードが不可解だという苦情が来始めたら、長い名前を使うことを検討すべきです（「Go言語 短い名前」でWeb検索すると、そのような苦情がいくつか見つかります）。\n同様に、変数名が長いとコードが読みにくいという苦情が来始めたら、短い変数名を使うことを検討します。\nGerrandは、私が同意するコメントを1つしています。「名前の宣言とその用途の間に距離があればあるほど、名前は長くすべきです」。\n先ほどのiとjという名前のループ変数を使う話は、このルールの一例です。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-26",
      "body_markdown": "## 14.7 結論 \n\n初めてその変数に出会ったとき、あまり考えずに行ったその変数の動作に関する最初の推測が正しくなるように、よく選ばれた名前はコードをより明白にするのに役立ちます。\n良い名前を選ぶことは、第3章で説明した投資マインドの一例です。前もって少し余分に時間をかけて良い名前を選んでおけば、将来的にコードに手を加えることが容易になります。\nまた、バグを発生させる可能性も低くなります。ネーミングのスキルを身につけることも投資です。平凡な名前を設定するのをやめようと思った当初は、良い名前を思いつくのにイライラしたり、時間がかかったりするかもしれません。\nしかし、経験を積めば積むほど、それが簡単になることに気づくでしょう。最終的には、良い名前を選ぶのにほとんど余計な時間がかからなくなり、ほとんどタダ同然の効果を得られるようになるのです。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-27",
      "body_markdown": "## 15 まずコメントを書く(設計プロセスの一部としてコメントを使用する）。\n\n多くの開発者は、コーディングとユニットテストが完了した後、開発プロセスの最後にドキュメントを書くことを先延ばしにしています。\nこれは、質の悪いドキュメントを作成する最も確実な方法のひとつです。\nコメントを書くのに最適なのは、コードを書いている最中、プロセスの最初の方です。\nコメントを最初に書くことで、ドキュメンテーションを設計プロセスの一部とすることができます。\nこれは、より良いドキュメントを生み出すだけでなく、より良いデザインを生み出し、ドキュメントを書くプロセスをより楽しいものにします。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-27",
      "body_markdown": "## 15.1 遅延したコメントは悪いコメントである \n\n私がこれまでに出会った開発者のほとんどは、コメントを書くのを先延ばしにしていました。\nなぜもっと早くからドキュメントを書かないのかと尋ねると、彼らは「コードがまだ変化しているから」と答えます。早くからドキュメントを書くと、コードが変わったときに書き直さなければならないので、コードが安定するまで待ったほうがいいというのです。\nしかし、私は、もう一つの理由があると考えています。それは、ドキュメントを面倒な仕事だと考え、できるだけ先延ばしにしてしまうのです。\n残念ながら、この方法はいくつかの弊害をもたらします。\nまず、文書化を遅らせることは、文書が全く書かれなくなることを意味することが多い。\n一度遅らせることを始めると、もう少し遅らせることは簡単です。何しろ、あと数週間もすればコードはさらに安定するでしょうから。\nコードが間違いなく安定するころには、たくさんのコードが存在しています。つまり、ドキュメントを書くというタスクは巨大になり、さらに魅力的ではなくなっているのです。\n数日間立ち止まって足りないコメントをすべて埋めるような都合の良い時間は決してなく、プロジェクトにとって最善のことは、先に進んでバグを修正したり次の新機能を書いたりすることだと合理化するのは簡単なことなのです。\nそうすると、さらに文書化されていないコードができてしまいます。\nたとえ、コメントを書き直すだけの自制心があったとしても（自分をバカにしてはいけません：おそらくないでしょう）、そのコメントはあまり良いものではありません。\nこの時点で、あなたは精神的にチェックアウトしています。\nあなたの頭の中では、このコードは完成しており、次のプロジェクトに移ることを切望しているのです。\nコメントを書くことが正しいことだと分かっていても、楽しいものではありません。\nただ、できるだけ早く終わらせたいだけなのです。\nそこで、あなたはコードを手早く見直し、見栄えが良くなる程度のコメントを付けます。\nこの頃になると、設計から時間が経っているので、設計過程の記憶があいまいになってきます。\nコメントを書きながらコードを見るので、コメントはコードの繰り返しになります。\nコードからではわからない設計のアイデアを再構築しようとしても、覚えていないことが出てきます。\nこのように、コメントには、記述すべき最も重要なことが欠けているのです。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-27",
      "body_markdown": "## 15.2 最初にコメントを書く \n\nコメントを書くのに別のアプローチを使います。それは、コメントを一番最初に書くというものです。\n\n- 新しいクラスでは、クラスのインターフェイスコメントを書くことから始めます。\n- 次に、最も重要なパブリックメソッドについて、インターフェースコメントとシグネチャを書きますが、メソッド本体は空のままにしておきます。\n- そして、基本的な構造がほぼ完成するまで、これらのコメントに対して少しずつリテラシーを高めていきます。\n- この時点で、そのクラスで最も重要なインスタンス変数の宣言とコメントを書きます。\n- 最後に、メソッド本体を書き、必要に応じて実装コメントを加えます。\n- メソッド本体を書いていると、たいてい追加のメソッドやインスタンス変数が必要なことが分かってきます。新しいメソッドには、メソッド本体の前にインターフェースのコメントを書き、インスタンス変数には、変数宣言と同時にコメントを記入します。\n\nコードが完成したら、コメントも完成させます。\n書きかけのコメントが残ることはありません。\nコメント優先のアプローチには、3つの利点があります。\nまず、より良いコメントが書ける。\nクラスを設計しているときにコメントを書けば、設計上の重要な問題は記憶に新しいので、それを記録するのは簡単です。\nまた、各メソッドのインターフェイスコメントは本体よりも先に書いた方が、実装に気を取られることなくメソッドの抽象化とインターフェイスに集中できます。\nコーディングやテストの過程で、コメントの問題点に気づき、修正することができます。\nその結果、開発期間中にコメントが改善されていきます。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-27",
      "body_markdown": "## 15.3 コメントは設計の道具 \n\nコメントを最初に書くことの第二の、そして最も重要な利点は、システム設計を向上させることである。\nコメントは抽象化を完全に把握するための唯一の方法であり、優れた抽象化は優れたシステム設計の基本です。\n抽象度を記述するコメントを最初に書いておけば、実装コードを書く前に、抽象度を見直し、調整することができます。\n良いコメントを書くためには、変数やコードの断片の本質を見極める必要があります：この物事の最も重要な側面は何か？\n設計の初期段階でこの作業を行うことが重要です。そうでなければ、ただコードをハックしているだけになってしまいます。\nコメントは、複雑さを示す炭鉱のカナリアのようなものです。\nもしメソッドや変数が長いコメントを必要とするなら、それは良い抽象化ができていないことを示す赤信号です。\n第4章でクラスは深くあるべきだということを思い出してください。最高のクラスは、非常にシンプルなインターフェイスを持ちながら、強力な機能を実装しています。\nインターフェイスの複雑さを判断する最良の方法は、それを説明するコメントからです。\nもしあるメソッドのインターフェイスコメントが、そのメソッドを使うために必要なすべての情報を提供し、しかも短くてシンプルであれば、そのメソッドはシンプルなインターフェイスを持っているということになります。\n逆に、長くて複雑なコメントなしにメソッドを完全に記述する方法がない場合、そのメソッドは複雑なインターフェイスを持っています。\nメソッドのインターフェイスコメントと実装を比較することで、そのメソッドがどれだけ深いかを知ることができます。インターフェイスコメントが実装の主要な機能をすべて記述しなければならない場合、そのメソッドは浅いということになります。\n同じ考え方が変数にも当てはまります。変数を完全に説明するために長いコメントが必要な場合、それは正しい変数分解を選択していない可能性を示唆する赤信号です。\n全体として、コメントを書くという行為は、設計上の決定を早期に評価し、問題を発見し修正することを可能にします。\n\nメソッドや変数を説明するコメントは、シンプルでありながら完全であるべきです。\nもし、そのようなコメントを書くのが難しいと感じたら、それは記述しているものの設計に問題がある可能性があるという指標になります。\n\nもちろん、コメントは、それが完全で明確である場合にのみ、複雑さの良い指標となります。\nもし、メソッドインターフェイスのコメントを書いても、そのメソッドを呼び出すために必要な情報をすべて提供しなかったり、理解するのが難しいほど不可解なコメントを書いたりした場合は、そのコメントは、メソッドを呼び出すために必要な情報を提供していないことになります。\nそのコメントは、メソッドの深さを表すのに適切なものではありません。\n"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-27",
      "body_markdown": "## 15.4 早いコメントは楽しいコメント \n\nコメントを早く書くことの3つ目の利点は、コメントを書くのが楽しくなることです。\n私にとって、プログラミングで最も楽しい部分のひとつは、新しいクラスを設計する初期の段階です。\n私のコメントのほとんどは、この段階で書かれたもので、コメントは、私の設計上の決定の質を記録し、テストする方法なのです。\n私は、最も少ない言葉で完全かつ明確に表現できる設計を探し求めています。\nコメントがシンプルであればあるほど、自分のデザインに納得がいくので、シンプルなコメントを見つけることはプライドの源です。\nもし、あなたが戦略的にプログラミングをしていて、単に動くコードを書くことよりも、優れた設計をすることが主な目的であるならば、コメントを書くことは楽しいはずです。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-27",
      "body_markdown": "## 15.5 初期のコメントは高価か? \n\nここで、コメントを遅らせることの議論をもう一度してみましょう。それは、コードが進化するにつれてコメントを手直しするコストを避けるためです。\n単純な裏計算をすると、あまり節約にならないことがわかります。\nまず、コードやコメントを修正する時間も含めて、コードとコメントの入力に費やす開発時間の割合を試算してみましょう。\n仮にコード行数の半分がコメントであったとしても、コメントを書く時間は開発時間の5%程度に過ぎないでしょう。\nコメントを書く時間は、全開発時間の5%程度に過ぎないでしょう。\nコメントを最後まで遅らせても、このほんの一部しか節約できないので、あまり意味がありません。\nコメントを最初に書くということは、コードを書き始める前に抽象化がより安定することを意味します。\nこれは、おそらくコーディング中の時間を節約することになるでしょう。\nこれに対して、コードを先に書くと、コードを書きながら抽象化したものが進化していくでしょうから、コメントファーストのアプローチよりもコードの修正が必要になります。\nこれらの要素をすべて考慮すると、コメントを先に書いた方が全体として速い可能性があります。\n\nwww.DeepL.com/Translator（無料版）で翻訳しました。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-27",
      "body_markdown": "## 15.6 おわりに \n\nもし、あなたがまだコメントを先に書いたことがないのなら、試してみてください。\n慣れるまで十分粘ることです。\nそして、それがあなたのコメントの質、設計の質、そしてソフトウェア開発の全体的な楽しみにどのような影響を与えるか考えてみてください。\nしばらく試した後、あなたの経験と私の経験が一致するかどうか、またその理由とそうでない理由を教えてください。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-29",
      "body_markdown": "## 16 既存コードの修正 \n\n第1章では、ソフトウェア開発がどのように反復的かつ漸進的に行われるかを説明した。\n大規模なソフトウェアシステムは、一連の進化的な段階を経て開発され、各段階では新しい機能が追加され、既存のモジュールが変更されます。\nこれは、システムの設計が常に進化していることを意味します。\n成熟したシステムの設計は、最初の構想よりも、システムの進化の過程で行われる変更によって決定されるのです。\nこれまでの章では、初期設計と実装の段階で複雑性を排除する方法について説明しました。\n本章では、システムが進化する過程で複雑性が忍び込むのを防ぐ方法について説明します。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-29",
      "body_markdown": "## 16.1 戦略的であり続ける \n\n第3章では、戦術的プログラミングと戦略的プログラミングの違いを紹介しました。\n戦術的プログラミングでは、たとえ複雑さが増すとしても、何かを素早く動作させることが第一の目標です。\n一方、戦略的プログラミングでは、優れたシステム設計を生み出すことが最も重要な目標になります。\n戦術的なアプローチでは、すぐに雑なシステム設計になってしまいます。\n保守や拡張が容易なシステムを作りたいのであれば、「動く」だけでは不十分で、設計に優先順位をつけて戦略的に考えなければなりません。\nこの考え方は、既存のコードを修正する場合にも当てはまります。\n残念ながら、開発者が既存のコードに手を入れてバグフィックスや新機能の追加などの変更を行う場合、通常、戦略的に考えることはありません。\n典型的な考え方は、\"私が必要とすることを実現するためにできる最小限の変更は何か？\"というものです。\n開発者がこれを正当化するのは、変更されるコードに違和感があるためで、大きな変更は新たなバグを引き起こすリスクが高くなることを懸念しているのです。\nしかし、これでは戦術的なプログラミングになってしまいます。\nこのような最小限の変更を行うたびに、いくつかの特殊なケースや依存関係、その他の複雑な形態が導入されます。\nその結果、システム設計は少しずつ悪化し、システムの進化に伴って問題が蓄積されていくのです。\nシステムの設計をきれいに保ちたいのであれば、既存のコードを修正する際に戦略的なアプローチを取る必要があります。理想的には、各変更を終えたときに、最初からその変更を念頭に置いて設計した場合の構造を持ったシステムになっていることです。\nこの目標を達成するためには、手っ取り早く修正しようという誘惑に負けないようにしなければなりません。\nその代わりに、現在のシステム設計が、求める変化に照らして、なお最適なものであるかどうかを考えましょう。\nもし、そうでなければ、最適な設計になるようにシステムをリファクタリングしてください。\nこの方法では、システム設計は修正されるたびに改善されていきます。\nこれは、15ページで紹介した投資マインドの一例でもあります。リファクタリングやシステム設計の改善のために少し余分に時間を投資すれば、よりクリーンなシステムを手に入れることができます。\nそうすれば、開発のスピードが上がり、リファクタリングに費やした労力も回収できます。\nたとえリファクタリングが必要ない場合でも、コードの中に修正可能な設計上の欠陥がないかどうか目を光らせておく必要があります。\n何かコードを修正するときはいつでも、その過程で少なくとも少しはシステム設計を改善する方法を見つけるようにしましょう。\nもし、設計を改善しないのであれば、おそらく設計を悪化させていることになります。\n第3章で述べたように、投資的な考え方は、時に商用ソフトウェア開発の現実と相反することがあります。正しい方法で」システムをリファクタリングすると3ヶ月かかるが、素早く汚い方法で修正すると2時間しかかからないとしたら、特に締め切りに追われている場合は、素早く汚い方法を取らざるを得ないかもしれません。\nまた、システムをリファクタリングすることで、他の多くの人やチームに影響を与える非互換性が生じる場合は、リファクタリングが現実的でない可能性もあります。\nそれでも、こうした妥協にはできる限り抵抗すべきです。\n\"今の制約の中で、きれいなシステム設計を作るためにできることは、これがベストなのか？\"と自問してみてください。\nもしかしたら、3ヶ月のリファクタリングとほとんど同じようにクリーンでありながら、数日でできる別のアプローチがあるのではないでしょうか？\nあるいは、今すぐ大規模なリファクタリングを行う余裕がないのであれば、現在の締め切りを過ぎてからまた戻ってこられるように上司に時間を割り当ててもらいましょう。\nすべての開発組織は、クリーンアップとリファクタリングに全労力のほんの一部を費やす計画を立てるべきです。この作業は、長い目で見ればそれだけで元が取れるでしょう。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-29",
      "body_markdown": "## 16.2 コメントの維持：コメントをコードの近くに配置する \n\n既存のコードを変更する場合、その変更によって既存のコメントの一部が無効になる可能性が高いです。\nコードを変更したときにコメントを更新するのを忘れがちで、その結果、正確でなくなったコメントが発生します。\n古くなったコメントは読者をイライラさせ、それが非常に多い場合、読者はすべてのコメントに不信感を抱くようになります。\n幸いなことに、ちょっとした規律といくつかの指導的なルールがあれば、大きな努力をしなくてもコメントを最新の状態に保つことは可能です。\nこのセクションと次のセクションで、いくつかの具体的なテクニックを紹介します。\nコメントを確実に更新する最良の方法は、そのコメントが記述されているコードの近くに配置することで、開発者がコードを変更したときにそのコメントが目に入るようにすることです。\nコメントが関連するコードから離れれば離れるほど、適切に更新される可能性は低くなります。\n例えば、メソッドのインターフェイスコメントの最適な場所は、コードファイルの中でメソッドのボディのすぐ隣にあります。\nメソッドへの変更はこのコードに関わるので、開発者はインターフェイスコメントを見て、必要であれば更新する可能性が高いのです。\nCやC++のようにコードとヘッダーファイルが分かれている言語では、.hファイルのメソッドの宣言の隣にインターフェイスコメントを配置するという方法があります。\n開発者はメソッドのボディを修正するときにこれらのコメントを見ることができませんし、別のファイルを開いてインターフェイスコメントを見つけて更新するためにさらなる作業が必要になります。\nユーザがコードファイルを見ることなく抽象化の使い方を学べるように、インターフェースのコメントはヘッダーファイルに書くべきだと主張する人もいるかもしれません。\nしかし、ユーザはコードもヘッダーファイルも読む必要はなく、DoxygenやJavadocのようなツールでコンパイルされたドキュメントから情報を得るべきでしょう。\nまた、多くのIDEは、メソッド名を入力するとそのメソッドのドキュメントを表示するなど、ドキュメントを抽出してユーザに提示する。\nこのようなツールがある以上、ドキュメントはコードを書く開発者にとって最も便利な場所に配置されるべきです。\n実装のコメントを書くときは、メソッド全体のコメントをメソッドの先頭にまとめてはいけません。\n各コメントは、そのコメントによって参照されるすべてのコードを含む最も狭い範囲に押し込まれるように、それらを広げます。\nたとえば、あるメソッドが3つの主要なフェーズを持つ場合、メソッドの先頭にすべてのフェーズの詳細を説明する1つのコメントを書かないでください。\nその代わり、各フェーズに個別のコメントを書き、そのコメントをそのフェーズのコードの最初の行のすぐ上に配置します。一方、メソッドの実装の一番上に、以下のように全体的な戦略を説明するコメントを記述することも有効です。\n\n```\n// 我々は3つのフェーズで進行する。\n// フェーズ1: 実行可能な候補を見つける \n// フェーズ2: 各候補にスコアを割り当てる \n// フェーズ 3: 最良のものを選び、削除する \n```\n\n各フェーズのコードのすぐ上には、追加の詳細を記述することができます。\n一般に、コメントは記述するコードから離れれば離れるほど、より抽象的であるべきです（これにより、コードの変更によってコメントが無効になる可能性を減らすことができます）。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-31",
      "body_markdown": "## 16.3 コメントはコミットログではなくコードに書くべし \n\nコードを修正する際によくある間違いは、ソースコードリポジトリのコミットメッセージに変更点の詳細な情報を記載し、それをコードに記載しないことです。\nコミットメッセージは将来リポジトリのログをスキャンすることで参照できますが、その情報を必要とする開発者がリポジトリのログをスキャンしようと考えることはまずありません。\nたとえログをスキャンしたとしても、正しいログメッセージを見つけるのは面倒なことでしょう。\nコミットメッセージを書く際には、開発者が将来その情報を使う必要があるかどうかを自問してください。\nもしそうなら、その情報をコードで文書化します。例えば、コード変更の動機となった微妙な問題を記述したコミットメッセージがあります。\nもしこの情報をコードに記述しておかなければ、開発者が後からやってきて、バグを再発生させたことに気づかずに変更を元に戻してしまうかもしれません。\nもしあなたがこの情報のコピーをコミットメッセージにも含めたいのであれば、それはそれで構いません。\n最も重要なことは、それをコードに反映させることです。\nこれは、開発者が最も目にする可能性の高い場所にドキュメントを配置するという原則を表しています。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-31",
      "body_markdown": "## 16.4 コメントの維持：重複を避ける \n\nコメントを最新に保つための第二のテクニックは、重複を避けることです。\nドキュメントが重複していると、開発者が関連するコピーをすべて見つけて更新することが難しくなります。\nその代わり、設計上の決定事項は一度だけ文書化するようにします。\nもし、ある決定の影響を受ける箇所がコード内に複数ある場合は、それぞれの箇所でドキュメントを繰り返し作成する必要はありません。\nその代わりに、最もわかりやすい場所を1カ所だけ選んで、その場所に文書を配置します。\nたとえば、ある変数に関連するトリッキーな動作があり、その変数が使用される複数の場所に影響を与えるとします。\nその挙動は、変数の宣言の横にあるコメントで説明することができます。\nこれは、開発者がその変数を使ったコードを理解するのに苦労したときに、自然に確認する場所です。\n特定のドキュメントを開発者が見つけやすい場所に置くための「明白な」単一の場所がない場合、セクション 13.7 で説明するように designNotes ファイルを作成します。\nあるいは、利用可能な場所の中から最適な場所を選び、そこにドキュメントを配置します。\nさらに、他の場所には、中心となる場所を参照する短いコメントを追加してください。\"以下のコードの説明は、xyzのコメントを参照してください。\" \nマスターコメントが移動または削除されたために参照が古くなった場合、開発者は指定された場所にコメントを見つけることができないので、この矛盾は自明となります。\n対照的に、もし文書が複製され、そのうちのいくつかが更新されなければ、開発者は古い情報を使っていることを知ることができません。\nあるモジュールの設計上の決定を、別のモジュールで再ドキュメント化しないこと。\n例えば、メソッド呼び出しの前に、呼び出されたメソッドで何が起こるかを説明するコメントを書かないことです。\nもし読者が知りたければ、そのメソッドのインターフェイスコメントを見るべきです。\n優れた開発ツールは通常、この情報を自動的に提供します。例えば、メソッドの名前を選択するか、マウスをメソッドの上に置くと、そのメソッドのインターフェイスコメントが表示されるのです。\n開発者が適切なドキュメントを簡単に見つけられるようにすること。\nもし、あなたのプログラムの外部のどこかにすでに文書化されている情報があれば、プログラムの内部でその文書を繰り返さないようにしてください。\n外部のドキュメントを参照すればよいのです。\n例えば、HTTPプロトコルを実装するクラスを書いた場合、HTTPプロトコルをプログラム内で説明する必要はありません。\nこのようなドキュメントは、すでにWeb上に多数存在します。これらのソースのURLをコードに短いコメントとして追加するだけでよいのです。\nもう一つの例は、ユーザーマニュアルにすでに記述されている機能です。\n例えば、コマンドのコレクションを実装するプログラムを書いていて、1つのメソッドが各コマンドの実装を担当しているとします。\nもし、それらのコマンドを説明したユーザーマニュアルがあれば、その情報をコードに重複して記載する必要はありません。\n代わりに、各コマンドメソッドのインターフェイスコメントに以下のような短いメモを入れます。\n// Fooコマンドを実装しています。詳細はユーザーマニュアルを参照してください。\n読者があなたのコードを理解するために必要なすべてのドキュメントを簡単に見つけられるようにすることは重要ですが、それはあなたがそのドキュメントをすべて書かなければならないということではありません。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-31",
      "body_markdown": "## 16.5 コメントのメンテナンス: 差分をチェックする\n\nドキュメントを最新の状態に保つための良い方法のひとつは、リビジョン管理システムに変更をコミットする前に数分かけて、そのコミットに対するすべての変更点をスキャンすることです。\n\nこのようなコミット前のスキャンは、誤ってデバッグコードをシステムに残してしまったり、TODO項目を修正しなかったりといった、他のいくつかの問題も検出することができます。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-08-31",
      "body_markdown": "## 16.6 より高度なコメントは保守しやすい \n\nドキュメントを維持するための最後の考えとして、コメントはコードよりも高レベルで抽象的である方が維持しやすくなります。\nこれらのコメントはコードの詳細を反映しないので、ちょっとしたコードの変更には影響されません。全体的な動作の変更のみがこれらのコメントに影響します。\nもちろん、第13章で説明するように、詳細で正確なコメントが必要な場合もあります。\nしかし、一般的には、最も有用なコメント (単にコードを繰り返すだけではない) は、メンテナンスも簡単です。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-01",
      "body_markdown": "## 17 一貫性\n\n一貫性とは、システムの複雑さを軽減し、その動作をより明白にするための強力なツールです。\nシステムが一貫しているということは、同じようなことは同じような方法で行われ、異なることは異なる方法で行われることを意味します。一旦、ある場所で何かがどのように行われるかを学んだら、その知識を使って、同じアプローチを使用している他の場所をすぐに理解することができる。\nもし、システムが一貫した方法で実装されていなければ、開発者はそれぞれの状況について個別に学ばなければなりません。これでは、より多くの時間がかかってしまいます。\n一貫性があれば、ミスは減ります。\nシステムに一貫性がないと、2つの状況が同じに見えても、実際には異なる場合があります。\n開発者は、見慣れたパターンを見て、そのパターンに過去に遭遇したことに基づいて、誤った仮定をしてしまうかもしれません。\n一方、システムが一貫していれば、見慣れた状況に基づいて行った推測は安全です。\n一貫性があれば、開発者はより迅速に、より少ないミスで作業を行うことができます。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-01",
      "body_markdown": "## 17.1 整合性の例 \n\n一貫性は、システム内の多くのレベルで適用することができます。ここでは、いくつかの例を示します。\n名前 14章では、一貫した方法で名前を使用することの利点についてすでに説明しました。\nコーディングスタイル。最近では、開発組織がスタイルガイドを持ち、コンパイラが強制する規則以上にプログラム構造を制限することが一般的になっています。\n最近のスタイルガイドは、インデント、波括弧の配置、宣言の順序、命名、コメント、危険とされる言語機能の制限など、さまざまな問題を扱っている。\nスタイル・ガイドラインは、コードを読みやすくし、ある種のエラーを減らすことができます。\nインターフェイス 複数の実装を持つインターフェースも、一貫性の一例です。\nあるインターフェースの実装を理解すれば、他の実装も理解しやすくなり、その実装が提供しなければならない機能が既に分かっているからです。\nデザインパターン。デザインパターンは、ユーザーインターフェース設計におけるモデル・ビュー・コントローラーアプローチのような、ある共通の問題に対する一般に認められた解決策です。\n既存のデザインパターンを使って問題を解決できれば、実装がより迅速に進み、動作する可能性が高くなり、コードが読者にとってより明白になる。\nデザインパターンについては、セクション 19.5 で詳しく説明します。\n不変量。不変量とは、常に真である変数や構造体の特性のことです。\nたとえば、テキストの行を保存するデータ構造では、各行の終端が改行文字であるという不変量が適用されます。\n不変量は、コードで考慮しなければならない特殊なケースの数を減らし、コードの動作についての推論を容易にします。\n動作の推論が容易になります。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-01",
      "body_markdown": "## 17.2 一貫性を確保する \n\n一貫性を維持することは、特に多くの人が長期間にわたってプロジェクトに携わる場合、困難です。\nあるグループの人々は、別のグループで確立された慣習を知らないかもしれません。\n新参者はルールを知らないので、意図せず慣習に違反したり、既存のものと衝突する新しい慣習を作ったりします。\nここでは、一貫性を確立し、維持するためのいくつかのヒントを紹介します。\n\n文書化する。\nコーディングスタイルガイドラインのような、全体的に最も重要な規約を列挙したドキュメントを作成する。\nこの文書は、プロジェクトの Wiki の目立つ場所など、開発者が目にする可能性のある場所に置きます。\n新しくグループに参加する人にはこのドキュメントを読むように勧め、既存の人にはたまにレビューするように勧める。\n様々な組織からいくつかのスタイルガイドがウェブ上で公開されていますので、まずはこれらの中から始めることを検討してください。\n不変量など、より局所的な規約については、コードの中で適切な場所を探して文書化します。\nもし、あなたが規約を書き留めないなら、他の人がそれに従うことはまずないでしょう。\n\n実行する \n良い文書があっても、開発者がすべての規約を覚えておくことは困難です。\n規約を強制する最善の方法は、規約違反をチェックするツールを作成し、チェッカーに合格しない限りコードをリポジトリにコミットできないようにすることです。\n自動チェッカーは、特に低レベルの構文規則に対して効果的だ。\n私の最近のプロジェクトでは、行末文字に問題がありました。\n開発者の中には、改行で行を終了させるUnixを使っている人もいれば、Windowsを使っている人もいました。\nWindowsでは、行の終わりは通常、キャリッジリターンと改行で終わります。\n一方のシステムで編集したファイルを他方のシステムで編集した場合、エディターが行の終端記号をすべてそのシステムに適したものに置き換えてしまうことがありました。\nこれでは、あたかもファイルのすべての行が変更されたように見え、意味のある変更を追跡することが難しくなります。\n私たちは、ファイルには改行だけを入れるという慣習を作りましたが、すべての開発者が使うすべてのツールがその慣習に従っているかどうかを確認するのは困難でした。\n新しい開発者がプロジェクトに参加するたびに、その開発者が慣れるまで改行の問題が多発したのです。\n最終的には、ソースコードレポジトリに変更をコミットする前に自動的に実行される短いスクリプトを作成することで、この問題を解決しました。\nこのスクリプトは、変更されたすべてのファイルをチェックし、その中にキャリッジリターンが含まれている場合はコミットを中止します。\nこのスクリプトは手動で実行することもでき、キャリッジリターンとニューラインのシーケンスをニューラインに置き換えて、破損したファイルを修復することができます。\nこれにより、問題が即座に解消され、新しい開発者のトレーニングにもなりました。\nコードレビューもまた、規約を徹底させ、新しい開発者に規約を教育する機会を提供する。\nコードレビューの担当者が細かいことを言えば言うほど、チームの全員がより早く規約を習得し、よりきれいなコードになります。\nよりきれいなコードになります。\n\n郷に入っては郷に従え ... \n最も重要な規約は、すべての開発者が「When in Rome, do as the Romans do」という古い格言に従うべきということです。\n新しいファイルで作業するときは、既存のコードがどのような構造になっているかを見て回ります。\nすべてのパブリック変数とメソッドは、プライベート変数より先に宣言されていますか？\nメソッドはアルファベット順に並んでいるか？\n変数はfirstServerNameのように「キャメルケース」、first_server_nameのように「スネークケース」のどちらを使っているか？\nこのような慣習のようなものを見かけたら、それに従いましょう。\nもしそうなら、既存の例を見つけ、新しいコードで同じアプローチを使用します。\n既存の慣習を変えない。\n既存の慣習を「改良」したい衝動に駆られないようにしましょう。\nより良いアイデアがある」というのは、矛盾を引き起こす十分な言い訳にはなりません。\nしかし、矛盾に対する一貫性の価値は、あるアプローチに対する別のアプローチの価値よりも、ほとんどの場合、より大きいのです。\n矛盾した動作を導入する前に、2つの質問を自分に投げかけてみてください。\n第一に、古い慣習が確立されたときにはなかった、あなたのアプローチを正当化する重要な新しい情報を持っているか？\n第二に、新しいアプローチは、時間をかけて古い使用法をすべて更新する価値があるほど優れているか？\nこの2つの質問に対する答えが「イエス」である場合、アップグレードに踏み切りましょう。\nしかし、他の開発者が新しい慣習を知らないために、将来的に古いアプローチを再導入してしまうというリスクはまだ残っています。\n全体として、確立された慣習を再考することは、開発者の時間を有効に使うことではありません。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-01",
      "body_markdown": "## 17.3 行き過ぎた行為 \n\n一貫性とは、似たようなことを似たような方法で行うだけでなく、似て非なるものを異なる方法で行うことを意味します。\nもしあなたが一貫性に熱中し、本当に異なるものに同じ変数名を使ったり、パターンに合わないタスクに既存のデザインパターンを使ったりして、異質なものを同じアプローチで強制しようとするなら、複雑さと混乱を生み出すことになるでしょう。\n一貫性があるのは、開発者が \"xのように見えるなら、それは間違いなくxだ \"という確信を持っているときだけです。",
      "body_updated_at": "2022-09-01"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-01",
      "body_markdown": "## 17.4 結論 \n\n一貫性は、投資マインドのもう一つの例です。\n一貫性を確保するためには、少し余分な作業が必要になります。規約を決める作業、自動チェッカーを作成する作業、新しいコードで模倣する類似の状況を探す作業、コードレビューでチームを教育する作業などがあります。\nこの投資に対する見返りは、コードがより明白になることです。\n開発者はコードの挙動をより早く正確に理解できるようになり、より速く、より少ないバグで作業することができるようになります。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-02",
      "body_markdown": "## 18 コードは明白であるべき \n\n不純物は、セクション 2.3 で説明した複雑さの 2 大原因の 1 つです。\n不明瞭さとは、システムに関する重要な情報が、新しい開発者にとって明白でない場合に発生します。\n不明瞭さの問題の解決策は、コードが明白になるように書くことです。この章では、コードを明白にする、または明白でなくする要因のいくつかを説明します。\nコードが明白であるということは、誰かがあまり考えずに素早くコードを読むことができ、そのコードの動作や意味に関する最初の推測が正しいことを意味します。\nコードの動作や意味に関する最初の推測が正しくなることを意味します。\nコードが明白であれば、読者はコードを扱うために必要なすべての情報を収集するために多くの時間や労力を費やす必要はありません。\nコードが自明でない場合、読者はコードを理解するために多くの時間とエネルギーを費やす必要があります。\nこれは作業効率を下げるだけでなく、誤解やバグが発生する可能性も高くなります。\n明らかなコードは、明らかでないコードよりも少ないコメントしか必要としません。\n\"自明 \"とは読む人の心の中にあるものです。自分のコードの問題点に気づくより、他人のコードが自明でないことに気づく方が簡単です。\nしたがって、コードの自明性を判断する最良の方法は、コードレビューを通じて行うことです。\nもし、あなたのコードを読んだ誰かが自明でないと言ったら、あなたにはどんなに明確に見えても、それは自明ではないのです。\n何がそのコードを自明でないものにしたのかを理解しようとすることで、今後よりよいコードを書くための方法を学ぶことができます。",
      "body_updated_at": "2022-09-02"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-02",
      "body_markdown": "## 18.1 コードをより分かりやすくするためのもの\n\nコードを明白にするための最も重要な2つのテクニックは、すでに前の章で説明しました。\n1つ目は、良い名前を選ぶことです（第14章）。\n正確で意味のある名前は、コードの振る舞いを明確にし、ドキュメントの必要性を低減します。\n名前が曖昧であれば、読者はコードを読んでその実体の意味を推測しなければなりません。\nこれは時間がかかり、エラーを引き起こしやすくなります。\n2つ目のテクニックは「一貫性」です（第17章）。\n同じようなことがいつも同じような方法で行われていれば、読者は以前見たことのあるパターンを認識し、コードを詳しく分析しなくてもすぐに（安全な）結論を導き出すことができるのです。\nその他、コードを分かりやすくするための汎用的なテクニックをいくつか紹介します： 空白をうまく利用する。\nコードの書式は、コードの理解しやすさに影響を与えることがあります。例えば、次のようなパラメータのドキュメントを考えてみましょう。\n\n\nあるパラメータのドキュメントがどこで終わり、次のパラメータが始まるのかがわかりません。\nあるパラメータのドキュメントがどこで終わり、次のパラメータが始まるのか、また、何個のパラメータがあるのか、その名前が何なのかさえ明らかではありません。空白を少し入れると、構造が明らかになり、文書が読みやすくなります。\n\n \nまた、次の例のように、空白行はメソッド内の主要なコードブロックを区切るのにも便利です。\n\nこの方法は、各空白行の後の最初の行が次のコードのブロックを説明するコメントである場合に特に効果的です：空白行はコメントをより見やすくします。\n\n文の中の空白は、文の構造を明確にするのに役立ちます。次の2つの文を比べてみてください。一方は空白があり、もう一方は空白がありません。\n\nコメント 時には、明白でないコードを避けることができないことがあります。\nそんなときは、コメントで足りない情報を補うことが大切です。\nこれをうまくやるには、読者の立場に立って、何が読者を混乱させるか、どのような情報がその混乱を解消するのかを考えなければなりません。\n次の章では、いくつかの例を紹介します。",
      "body_updated_at": "2022-09-02"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-02",
      "body_markdown": "## 18.2 コードを目立たなくするもの \n\nコードを目立たなくするものはたくさんあります。このセクションでは、いくつかの例を紹介します。\nイベントドリブンプログラミングのように、これらのいくつかは、いくつかの状況で有用であるため、あなたはとにかくそれらを使用することになるかもしれません。このような場合、特別なドキュメントを用意することで、読者の混乱を最小限に抑えることができます。\nイベント駆動型プログラミング。イベント駆動型プログラミングでは、ネットワークパケットの到着やマウスボタンの押下など、外部からの事象にアプリケーションが反応する。\nあるモジュールは、受信したイベントの報告を担当します。\nアプリケーションの他の部分は、イベントが発生したときに所定の関数やメソッドを呼び出すようイベントモジュールに依頼することで、特定のイベントに対する関心を登録します。\nイベントドリブンプログラミングでは、制御の流れを追うことが難しくなります。\nイベントハンドラ関数は、直接呼び出されることはなく、イベントモジュールから間接的に呼び出されます。\n関数ポインタやインターフェイスを使って間接的に呼び出されます。\nイベントモジュールの中で呼び出されるポイントを見つけたとしても、どの関数が呼び出されるかはわかりません。これは、実行時にどのハンドラが登録されたかに依存します。\nこのため、イベントドリブンのコードを推論することも、それが機能することを納得させることも困難です。\nこの不明瞭さを補うために、各ハンドラ関数のインターフェイスコメントを使用します。\nを使うことで、ハンドラ関数がいつ呼び出されるかを示すことができます。\nの例です。\n\n*****************************\nコードの意味や動作が、ぱっと読んだだけでは理解できない場合は、赤信号です。\n多くの場合、これはコードを読んだ人がすぐに理解できない重要な情報があることを意味します。\n******************************\n\n汎用的なコンテナ \n多くの言語では、2つ以上の項目を1つのオブジェクトにまとめるための汎用クラスが用意されています（JavaのPairやC++のstd::pairなど）。\nC++のstd::pairのようなものです。\nこれらのクラスは、1つの変数で複数のオブジェクトを簡単に受け渡しできるため、魅力的な存在です。\n最も一般的な使い方は、このJavaの例のように、あるメソッドから複数の値を返すことです。\n残念ながら、ジェネリックコンテナは、グループ化された要素に一般的な名前がついているため、意味がよくわからないコードになってしまいます。\n上記の例では、呼び出し側はresult.getKey()とresult.getValue()で2つの返された値を参照しなければなりませんが、これでは値の実際の意味について何の手がかりも得られません。\nしたがって、汎用コンテナは使用しない方がよいでしょう。\nもしコンテナが必要なら、特定の用途に特化した新しいクラスや構造体を定義してください。\nそうすれば、要素に意味のある名前を使うことができますし、宣言の中で追加のドキュメントを提供することができます。\nこれは、一般的なコンテナでは不可能なことです。\nこの例は、一般的なルールである「ソフトウェアは書きやすさではなく、読みやすさを重視して設計されるべき」であることを物語っています。\n一般的なコンテナは、コードを書く人にとっては便利ですが、後に続くすべての読者にとって混乱を引き起こします。\nコードを書く人は、数分余計に時間をかけて特定のコンテナ構造を定義した方が、出来上がったコードがより明白になります。\n宣言と割り当てで異なる型 \n次のようなJavaの例を考えてみましょう。\n変数はListと宣言されているが、実際の値はArrayListである。\nListはArrayListのスーパークラスなので、このコードは合法ですが、宣言だけを見て実際の割り当てを知らない読者に誤解を与える可能性があります。\nこのコードは合法です。\n実際の型は、その変数がどのように使われるかに影響します (ArrayList は List の他のサブクラスとは性能とスレッドセーフの特性が異なります)。\nそのため、宣言と割り当てを一致させたほうがよいでしょう。\n読者の期待を裏切るコード \nJavaアプリケーションのメインプログラムである、次のコードを考えてみましょう。\nほとんどのアプリケーションは、メインプログラムが戻ったときに終了するので、読者はここでそうなると思いがちです。\nしかし、そうではありません。\nRaftClientのコンストラクタは追加のスレッドを生成し、アプリケーションのメインスレッドが終了しても、スレッドは動作し続けます。\nこの動作は、RaftClientのコンストラクタのインタフェース・コメントに記述されるべきですが、その動作は明白ではないので \nは明白でないため、mainの末尾に短いコメントを記述する価値があります。\nこのコメントには、アプリケーションが他のスレッドで実行され続けることを示す必要があります。\nもし、そうでなければ、読者が混乱しないように、その動作を文書化することが重要です。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-02",
      "body_markdown": "## 18.3 結論 \n\n自明性について考えるもう一つの方法は、情報という観点から考えることである。\nコードが自明でない場合、それは通常、読者が持っていないコードに関する重要な情報があることを意味します。\nRaftClient の例では、RaftClient のコンストラクタが新しいスレッドを生成することを読者は知らないかもしれませんし、pair の例では result.getKey() が現在の項番号を返すことを読者は知らないかもしれません。\n\nコードを明白にするためには、読者がコードを理解するために必要な情報を常に持っているようにする必要があります。\nこれには、3つの方法があります。\n一番良い方法は、抽象化や特殊なケースの排除などの設計テクニックを使って、必要な情報の量を減らすことです。\n次に、読者が他の文脈ですでに獲得している情報を利用することです。\n第二に、読者が他の文脈で既に習得している情報（例えば、慣習に従う、期待に沿うなど）を利用することで、読者があなたのコードのために新しい情報を学習する必要がなくなります。\n第三に、良い名前や戦略的なコメントなどのテクニックを使って、コードの中で重要な情報を読者に提示することができます。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-03",
      "body_markdown": "## 19 \n\n本書で取り上げた原則を説明する方法として、本章では、いくつかのトレンドとパターンを取り上げます。この章では、この本で議論されている原則を説明するために、ソフトウェア開発で一般的になっているいくつかのトレンドとパターン この数十年の間にソフトウェア開発で一般的になった この数十年の間にソフトウェア開発で普及したいくつかのトレンドとパターンを考察します。\n\n各トレンドについて、そのトレンドが本書の原則とどのように関連しているかを説明します。を説明し、その傾向が本書の原則にどのように関連しているかを説明します。この原則を使用して、そのトレンドがソフトウェアの複雑性を緩和するかどうかを評価します。\nを評価します。\n\n## 19.1 オブジェクト指向プログラミングと継承\n\nオブジェクト指向プログラミングは、過去30〜40年のソフトウェア開発における最も重要な新しい考え方の1つです。\n\nクラス、継承、プライベートメソッド、インスタンス変数などの概念が導入されました。\nこれらの仕組みを注意深く使えば、より優れたソフトウェア設計を実現することができる。\n例えば、プライベートメソッドやプライベート変数は、情報の隠蔽に利用することができます。クラスの外部にあるコードは、プライベートメソッドを呼び出したり、プライベート変数にアクセスしたりできないので、外部からの依存を排除することができるのです。\nオブジェクト指向プログラミングの重要な要素のひとつに継承がある。\n継承には2つの形式があり、ソフトウェアの複雑さに対して異なる意味を持ちます。\n第一の継承はインターフェース継承で、親クラスが一つ以上のメソッドのシグネチャを定義するが、メソッドを実装しない。\n各サブクラスはそのシグネチャを実装しなければならないが、異なるサブクラスは同じメソッドを異なる方法で実装することができる。\n例えば、インターフェースはI/Oを実行するためのメソッドを定義しているかもしれません。あるサブクラスはディスクファイルのI/O操作を実装し、別のサブクラスはネットワークソケットの同じ操作を実装するかもしれません。\nインターフェイスの継承は、同じインターフェイスを複数の目的で再利用することで、複雑性に対するレバレッジを提供します。\nある問題（例えばディスクファイルの読み書きのためのI/Oインターフェースの使い方）を解決するために得た知識を、他の問題（例えばネットワークソケットでの通信）の解決に利用することができるのです。\nあるインターフェースの実装が多ければ多いほど、そのインターフェースは深くなります。\nインターフェイスが多くの実装を持つためには、インターフェイスはすべての基本的な実装の本質的な特徴を捉え、実装間で異なる細部を排除する必要があります。\n第二の継承は、実装継承です。この形式では、親クラスは1つまたは複数のメソッドのシグネチャだけでなく、デフォルトの実装も定義します。\nサブクラスは、親クラスのメソッドの実装を継承するか、同じメソッドを定義してそれをオーバーライドするかを選択することができます。することができます。\n実装継承を行わない場合、同じメソッドの実装を複数のサブクラスで重複させる必要が生じる可能性があり、 それらのサブクラス間で依存関係が生じる (メソッドのすべてのコピーで修正を重複させる必要が生じる)。\nこのように、実装継承はシステムの進化に伴って変更されるコードの量を減らす、つまり、2章で説明した変更の増幅の問題を減らすことができます。\nしかし、実装継承を行うと、親クラスとその各サブクラスとの間に依存関係が生じます。\n親クラスのインスタンス変数は、親クラスと子クラスの両方からアクセスされることが多く、その結果、継承階層内のクラス間の情報漏洩が発生し、他のクラスを見ずに階層内のあるクラスを変更することが困難になります。\n例えば、親クラスに変更を加える場合、開発者はその変更が何かを破壊していないことを確認するために、すべてのサブクラスを調べる必要があるかもしれません。同様に、サブクラスが親クラスのメソッドをオーバーライドする場合、サブクラスの開発者は親クラスの実装を確認する必要があるかもしれません。最悪の場合、プログラマは親クラスの下にあるクラス階層全体を完全に把握しなければ、どのクラスにも変更を加えることができなくなります。\n実装継承を多用したクラス階層は、複雑なものになる傾向があります。\nしたがって、実装継承の使用には注意が必要です。\n実装継承を使用する前に、コンポジションに基づくアプローチで同じ利点が得られるかどうかを検討してください。\n例えば、共有機能を実装するために小さなヘルパークラスを使用することが可能かもしれません。\n親クラスから機能を継承するのではなく、元のクラスはそれぞれヘルパークラスの機能を基に構築することができます。\n実装継承に代わる実行可能な方法がない場合、親クラスが管理する状態とサブクラスが管理する状態を分離するようにします。\nこの方法のひとつは、特定のインスタンス変数をすべて親クラスのメソッドで管理し、 サブクラスは親クラスの下にあるクラス階層で変更できるようにすることです。\n実装継承を多用したクラス階層は、複雑化する傾向があります。\n\nしたがって、実装継承は注意して使用する必要があります。\n実装継承を使用する前に、コンポジションに基づくアプローチで同じメリットが得られるかどうかを検討してください。\n例えば、共有機能を実装するために小さなヘルパークラスを使用することが可能かもしれません。\n親クラスから機能を継承するのではなく、元のクラスはそれぞれヘルパークラスの機能を基に構築することができます。\nヘルパークラスの機能を利用することができます。\n実装継承に代わる実行可能な方法がない場合、親クラスが管理する状態とサブクラスが管理する状態を分離するようにします。\nこの方法のひとつは、特定のインスタンス変数を完全に親クラスのメソッドで管理し、 サブクラスでは読み取り専用にするか、親クラスの他のメソッドで使用するようにすることです。\nこれは、クラス階層内での情報隠蔽の考え方を応用したもので、依存性を低減することができる。\nオブジェクト指向の仕組みは、きれいな設計を実現するのに役立ちますが、それ自体が良い設計を保証するわけではありません。\n例えば、クラスが浅かったり、複雑なインターフェイスを持っていたり、内部の状態への外部からのアクセスを許可していたりすると、やはり高い複雑性をもたらすことになる。\n\n## 19.2 アジャイル開発 \n\nアジャイル開発は、1990年代後半にソフトウェア開発をより軽量化、柔軟化、漸進化する方法についてのアイデアを集めて生まれたソフトウェア開発のアプローチであり、2001年の実務家の会合で正式に定義されたものである。\nアジャイル開発は、主にソフトウェア開発のプロセス（チームの編成、スケジュールの管理、単体テストの役割など）に関するものである。\nアジャイル開発は、ソフトウェア設計とは対照的に、ソフトウェア開発のプロセス（チームの編成、スケジュールの管理、ユニットテストの役割、顧客との対話など）に関するものがほとんどです。\nそれでも、本書の設計原則のいくつかには関連しています。\nアジャイル開発の最も重要な要素の1つは、開発は漸進的かつ反復的であるべきという考え方である。\nアジャイルアプローチでは、ソフトウェアシステムは一連のイテレーションで開発され、各イテレーションでは、いくつかの新しい機能が追加され、評価されます。各イテレーションには、設計、テスト、および顧客からのインプットが含まれます。\nこれは，ここで提唱しているインクリメンタルアプローチに似ている．\n第1章でも述べたように，複雑なシステムをプロジェクト開始時に十分に可視化し，最適な設計を決定することは不可能である．\n良い設計に行き着くための最良の方法は、システムをインクリメンタルに開発することである。インクリメントごとに、いくつかの新しい抽象化を追加し、既存の抽象化を経験に基づいてリファクタリングするのである。\nこれはアジャイル開発のアプローチに似ている。\nアジャイル開発のリスクの1つは、戦術的なプログラミングにつながる可能性があることです。\nアジャイル開発は、開発者を抽象化ではなく機能に集中させる傾向があり、できるだけ早く実用的なソフトウェアを作るために設計の決定を先送りにするよう開発者を促します。\n例えば、アジャイルの実践者の中には、すぐに汎用的な機構を実装すべきではなく、まずは最小限の特殊な機構を実装し、それが必要だと分かった時点で、後でより汎用的なものにリファクタリングすべきだと主張する人たちがいます。\nこのような主張は、ある程度は理にかなっていますが、投資的なアプローチには反対で、より戦術的なスタイルのプログラミングを推奨しています。\nその結果、複雑さが急速に蓄積される可能性があります。\nインクリメンタルに開発することは一般的に良いアイデアですが、開発の増分は機能ではなく、抽象化であるべきです。\nある機能が必要になるまで、特定の抽象化について考えることをすべて先延ばしにしても構わない。いったん抽象化が必要になったら、それをきれいに設計するために時間を投資してください。第6章のアドバイスに従って、ある程度汎用的なものにしましょう。",
      "body_updated_at": "2022-09-03"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-06",
      "body_markdown": "## 19.3 単体テスト\n\n以前は、開発者がテストを書くことはほとんどありませんでした。もしテストを書くとしたら、それは別のQAチームが書いたものです。\nしかし、アジャイル開発の信条の1つは、テストは開発と密接に統合されるべきであり、プログラマは自分のコードのためにテストを書くべきだというものです。\nこの習慣は、現在では広く浸透している。\nテストは通常、ユニットテストとシステムテストの2種類に分けられる。\nユニットテストは、開発者によって最も頻繁に書かれるテストです。\nそれぞれのテストは通常、単一のメソッドにおけるコードの小さなセクションを検証します。\nユニットテストは、システムの本番環境をセットアップすることなく、単独で実行することができます。\nユニットテストは、しばしばテストカバレッジツールと一緒に実行され、アプリケーションのすべてのコード行がテストされていることを確認します。\n開発者は、新しいコードを書いたり、既存のコードを修正したりするたびに、適切なテストカバレッジを維持するためにユニットテストを更新する責任を負います。\nユニットテストを更新し、適切なテストカバレッジを維持する責任があります。\n2 番目の種類のテストは、システムテスト（統合テストと呼ばれることもあります）で、アプリケーションの異なる部分 がすべて適切に連動することを保証します。\nシステムテストは、通常、運用環境に近い状態でアプリケーション全体を実行することを伴います。\nシステムテストは、別の QA またはテストチームによって書かれることが多いようです。\nテスト、特にユニットテストは、リファクタリングを促進するため、ソフトウェア設計において重要な役割を果たします。テストスイートがなければ、システムに大きな構造的変更を加えることは危険である。\nバグを見つけるのが容易ではないため、新しいコードがデプロイされるまでバグが発見されない可能性が高く、発見と修正にはより多くのコストがかかります。\nその結果、開発者は優れたテストスイートのないシステムでのリファクタリングを避け、新機能やバグ修正のたびに行うコード変更の回数を最小限に抑えようとするので、複雑さが蓄積され、設計ミスが修正されなくなります。\n優れたテスト群があれば、開発者はリファクタリングの際に自信を持つことができます。なぜなら、テスト群は導入されたバグのほとんどを発見してくれるからです。\nこれにより、開発者はシステムの構造的な改善を行うことができ、結果としてより良い設計を行うことができます。\n特にユニットテストは、システムテストよりもコードカバレッジが高いので、バグを発見しやすいというメリットがあります。\n例えば、スクリプト言語Tclの開発では、Tclのインタプリタをバイトコードコンパイラに置き換えることで、パフォーマンスを向上させることにしました。\nこれは、Tclエンジンのコア部分のほとんどに影響を与える大きな変更だった。\n幸いなことに、Tclには優れたユニットテスト群があり、それを新しいバイトコードエンジンで実行した。\n既存のテストは新しいエンジンのバグを発見するのに非常に効果的で、バイトコードコンパイラのアルファ版リリース後に判明したバグは1つだけでした。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-06",
      "body_markdown": "## 19.4 テスト駆動開発 \nテスト駆動開発とは、プログラマがコードを書く前に単体テストを書くというソフトウェア開発のアプローチです。\n新しいクラスを作るとき、開発者はまずそのクラスのために、期待される動作に基づいたユニットテストを書きます。\nそのクラスにはコードがないので、どのテストもパスしません。\n次に、一度にひとつずつテストを行い、そのテストにパスするのに十分なコードを書いていきます。\nすべてのテストに合格したら、そのクラスは完成です。\n私はユニットテストの強力な支持者ですが、テスト駆動開発は好きではありません。\nテスト駆動開発の問題点は、最良の設計を見つけることよりも、特定の機能を動作させることに注意を集中させることです。\nこれは純粋に戦術的なプログラミングであり、そのデメリットをすべて含んでいます。\nテスト駆動開発は逐次的すぎる。どの時点でも、次のテストをパスするために次の機能をハックしたくなるものです。\n設計を行う明確なタイミングがないため、混乱した状態で終わってしまいがちです。\n19.2節で述べたように、開発の単位は機能ではなく、抽象化であるべきです。\n抽象化の必要性を発見したら、時間をかけて少しずつ抽象化を行うのではなく、一度に設計するようにしましょう。\nを一度に設計してください (または、少なくともコア機能の合理的な包括的セットを提供するのに十分な数)。\nそうすることで、断片がうまく組み合わされた、きれいな設計ができる可能性が高くなります。\nテストを最初に書くことが理にかなっているのは、バグを修正するときです。\nバグを修正する前に、そのバグのために失敗するユニットテストを書きます。\nそして、そのバグを修正し、そのユニットテストがパスすることを確認します。\nこれは、本当にバグを修正したのかどうかを確認するための最良の方法です。\nテストを書く前にバグを修正すると、新しい単体テストが実際にはバグを引き起こさない可能性があり、その場合、本当に問題を修正したのかどうかを知ることはできません。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-06",
      "body_markdown": "## 19.5 デザインパターン \n\nデザインパターンは、イテレーターやオブザーバーなど、特定の種類の問題を解決するためによく使われる手法です。\nデザインパターンという概念は、「デザインパターン」という本によって広まりました。Elements of Reusable Object-Oriented Software」（Gamma社）によって広まった。\nHelm, Johnson, and Vlissides著「Design Patterns: Elements of Reusable Object-Oriented Software」によって広まり、現在ではオブジェクト指向ソフトウェア開発において広く利用されている。\nデザインパターンは、ゼロから新しい仕組みを設計するのではなく、よく知られたデザインパターンを適用すればよいという、設計の代替手段を示すものである。\nデザインパターンは、一般的な問題を解決するために生まれたものであり、一般的にきれいな解決策を提供することが認められているからである。\nデザインパターンが特定の状況でうまく機能する場合、より優れた別のアプローチを考え出すのはおそらく困難でしょう。\nデザインパターンの最大のリスクは、過剰な適用です。\nすべての問題が、既存のデザインパターンできれいに解決できるわけではありません。カスタムアプローチの方がきれいに解決できるのに、問題を無理にデザインパターンに当てはめようとしないことです。\nデザインパターンを使えば、自動的にソフトウェアシステムが改善されるわけではありません。\nソフトウェアデザインにおける多くの考え方と同様に、デザインパターンが良いという考え方は、必ずしも以下のことを意味しません。\nということです。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-06",
      "body_markdown": "## 19.6 ゲッターとセッター \n\nJavaプログラミングコミュニティでは、ゲッターとセッターメソッド領域人気のあるデザインパターンです。\nゲッターとセッターは、クラスのインスタンス変数に関連付けられます。\nこれらはgetFooやsetFooのような名前を持っており、Fooは変数の名前です。\nゲッターメソッドは変数の現在の値を返し、セッターメソッドはその値を変更する。\nインスタンス変数は公開することができるので、ゲッターとセッターは厳密には必要ではありません。\nゲッターとセッターの利点は、取得や設定の際に、変数が変更されたときに関連する値を更新する、変更内容をリスナーに通知する、などの追加機能を実行できることです。\nを更新したり、リスナーに変更を通知したり、 値に制約をかけたりすることができます。\nこれらの機能は当初は必要なくても、後からインターフェイスを変更することなく追加することが可能です。\nインスタンス変数を公開しなければならない場合、ゲッターやセッターを使用することは理にかなっているかもしれませんが、そもそもインスタンス変数を公開しないほうがよいでしょう。\nインスタンス変数を公開するということは、クラスの実装の一部が外部から見えるということであり、情報隠蔽の考え方に反し、クラスのインターフェースの複雑さを増してしまうからです。\nゲッターとセッターは浅いメソッド (通常は一行だけ) であるため、大した機能を提供せずにクラスのインターフェイスを乱雑にしてしまいます。\nゲッターとセッター（あるいは実装データの公開）はできるだけ避けたほうがよいでしょう。\nデザインパターンを確立することのリスクのひとつは、開発者がそのパターンが優れていると思い込んで、できるだけ使おうとすることです。\nこのため、Javaではゲッターとセッターが過剰に使用されるようになりました。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-06",
      "body_markdown": "## 19.7 結論\n\n新しいソフトウェア開発パラダイムの提案に出会ったら、複雑さの観点からその提案に挑戦してください。\nその提案は本当に大規模なソフトウェアシステムの複雑性を最小化するのに役立っているのだろうか？\n多くの提案は表面的には良く聞こえますが、もっと深く見てみると、それらのいくつかは複雑さを改善するのではなく、悪化させるものであることが分かるでしょう。",
      "body_updated_at": "2022-09-06"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-07",
      "body_markdown": "## 20 性能のための設計 \n\nこれまで、ソフトウェア設計の議論では、複雑さに焦点をあててきました。目標は、ソフトウェアをできるだけ単純で理解しやすいものにすることでした。\nしかし、高速性が要求されるシステムの場合はどうでしょうか？\n性能を考慮することは、設計プロセスにどのように影響するのでしょうか？\nこの章では、きれいな設計を犠牲にすることなく、高いパフォーマンスを実現する方法について説明します。\n最も重要な考え方はやはりシンプルさです。シンプルさはシステムの設計を改善するだけでなく、通常、システムをより高速にします。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-07",
      "body_markdown": "## 20.1 パフォーマンスをどう考えるか \n\n最初に取り組むべき質問は、\"通常の開発プロセスにおいて、どの程度パフォーマンスを気にすべきか \"ということです。\nすべてのステートメントを最高速度に最適化しようとすると、開発のスピードが落ち、不必要な複雑さが多く発生します。\nさらに、「最適化」の多くは、実際には性能に貢献しないでしょう。\n一方、パフォーマンスの問題を完全に無視してしまうと、多くの \nその結果、システムは必要な速度の5倍から10倍も遅くなることがあるのです。\nこのような「千載一遇の死」のシナリオでは、大きな効果をもたらす単一の改良が存在しないため、後から戻ってパフォーマンスを改善することは困難です。\n最適なアプローチは、この両極端の中間で、性能に関する基本的な知識を使って、「自然に効率的」かつ「クリーンでシンプル」なデザインの選択肢を選ぶことです。\n重要なのは、どの操作が根本的にコストが高いかを認識することです。\n以下に、今日、比較的コストのかかる操作の例をいくつか挙げます。\n\n- ネットワーク通信：データセンター内であっても、メッセージの往復に10～50秒かかることがあり、これは何万回もの命令回数に相当します。\n広域のラウンドトリップは10-100msかかる。\n- 二次記憶装置へのI/O：ディスクの1/O処理には通常5～10ミリ秒かかり、これは数百万回の命令時間に相当します。\nフラッシュストレージは10-100usかかります。\n新しい不揮発性メモリは1usまで速くなるかもしれないが、それでも約2000命令回である。\n- 動的なメモリ割り当て（C言語ではmalloc、C++やJavaではnew）は、通常、割り当て、解放、ガベージコレクションに大きなオーバーヘッドを伴います。\n- キャッシュミス：DRAMからオンチッププロセッサキャッシュへのデータフェッチには数百回の命令時間がかかります。多くのプログラムでは、全体のパフォーマンスは、計算コストと同じくらいキャッシュミスによって決まります。\nどのようなものにコストがかかるかを知るには、マイクロベンチマーク（単一の操作のコストを個別に測定する小さなプログラム）を実行するのが一番です。\nRAMCloudプロジェクトでは、マイクロベンチマークのためのフレームワークを提供するシンプルなプログラムを作成しました。\nフレームワークの作成には数日かかりましたが、このフレームワークにより、5〜10分程度で新しいマイクロベンチマークを追加することが可能になりました。\nその結果、数十のマイクロベンチマークを蓄積することができました。\nこれらは、RAMCloudで使用されている既存のライブラリの性能を理解するためと、RAMCloud用に書かれた新しいクラスの性能を測定するための両方に使用しています。\n何が高価で何が安価かについての一般的な感覚がつかめれば、その情報を使って、可能な限り安価な処理を選択することができます。\n多くの場合、より効率的なアプローチは、より遅いアプローチと同じように単純になります。\n例えば、大きなオブジェクトのコレクションを保存し、キー値で検索する場合、ハッシュテーブルや順序付きマップを使用することができます。\nどちらもライブラリパッケージで一般的に提供されており、シンプルできれいに使うことができます。\nしかし、ハッシュテーブルの方が簡単に5-10倍速くなる。\nしたがって、マップが提供する順序付けの特性が必要でない限り、ハッシュテーブルを使用する必要があります。\n別の例として、CやC++のような言語で構造体の配列を確保することを考えてみましょう。\nこの場合、2つの方法があります。\nこの場合、まず配列の領域を確保し、次に個々の構造体の領域を確保しなければなりません。\n構造体を配列自体に格納する方がはるかに効率的で、すべての構造体に対してひとつの大きなブロックを割り当てるだけでよくなります。\nもし、効率を向上させる唯一の方法が、複雑さを増すことであるならば、選択はより難しくなります。\nより効率的な設計がわずかな量の複雑さを追加するだけで、その複雑さが隠されていて、どのインターフェースにも影響しないのであれば、価値があるかもしれません（ただし、注意：複雑さは漸進的です）。\nもし、より高速な設計が多くの実装を複雑にしたり、より複雑なインターフェイスになるなら、より単純なアプローチから始めて、パフォーマンスが問題になるなら後で最適化する方がよいかもしれません。\nということになります。\nしかし、ある特定の状況においてパフォーマンスが重要であるという明確な証拠があるのなら、より高速なアプローチをすぐに実装した方がよいでしょう。\nRAMCloudプロジェクトでは、データセンターのネットワークを介してストレージシステムにアクセスするクライアントマシンのレイテンシーを可能な限り小さくすることを全体的な目標の1つとしました。\nその結果、ネットワーク用に特別なハードウェアを使用することにしました。これにより、RAMCloudはカーネルをバイパスして、ネットワークインターフェースコントローラと直接通信してパケットを送受信できるようになりました。\nカーネルベースのネットワーキングは、事前の測定で私たちのニーズを満たすには遅すぎることがわかっていたので、複雑さが増すにもかかわらず、この決定を下しました。\nRAMCloud システムの他のほとんどの部分で、私たちはシンプルな設計をすることができました。この1つの大きな問題を「正しく」解決することで、他の多くのことがより簡単になりました。\n一般に、複雑なコードよりもシンプルなコードの方が、実行速度が速くなる傾向があります。\n特殊なケースや例外を排除して定義すれば、それらのケースをチェックするためのコードが不要になり、システムの実行速度が上がります。\n深いクラスは浅いクラスよりも効率的です。なぜなら、各メソッド呼び出しに対してより多くの仕事をこなすことができるからです。\n浅いクラスはレイヤーの交差が多くなり、レイヤーの交差ごとにオーバーヘッドが追加されます。\n\n"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-07",
      "body_markdown": "## 20.2 改造前(と改造後)の測定 \n\nしかし、上記のように設計したにもかかわらず、あなたのシステムがまだ遅すぎるとします。\n何が遅いのか、直感的に判断して、急いでパフォーマンスを調整し始めたくなります。\nしかし、そんなことはしてはいけません。プログラマーのパフォーマンスに関する直感は当てになりません。\nこれは、経験豊富な開発者であっても同じです。もしあなたが直感に基づいて変更を始めると、実際にパフォーマンスが向上しないことに時間を浪費することになり、その過程でシステムをより複雑にしてしまうかもしれません。\n変更を加える前に、システムの既存の挙動を測定してください。\nこれには2つの目的があります。まず、測定によって、性能チューニングが最も大きな影響を与える場所を特定します。トップレベルのシステム性能を測定するだけでは十分ではありません。\nこれでは、システムが遅すぎるということは分かっても、その理由は分かりません。\nより深く測定して、全体的な性能に寄与している要因を詳細に特定する必要があります。\n目標は、システムが現在多くの時間を費やしている場所や、改善の余地がある場所を特定することです。\n計測の第二の目的は、基準値を設定することです。これにより、変更後にパフォーマンスを再測定し、実際にパフォーマンスが向上したことを確認することができます。\nもし、変更によって性能に測定可能な差が出なかった場合は、（システムをよりシンプルにしない限り）その変更は取りやめてください。\n大幅なスピードアップをもたらさない限り、複雑さを評価する意味はありません。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-07",
      "body_markdown": "## 20.3 クリティカルパス周辺の設計 \n\nこの時点で、パフォーマンスを注意深く分析し、システム全体のパフォーマンスに影響を与えるほど遅いコードの一部を特定したと仮定しましょう。\nパフォーマンスを向上させる最善の方法は、次のような「根本的」な変更です。\nキャッシュの導入や、異なるアルゴリズム（バランスツリーとリストなど）の使用などです。\nRAMCloudのネットワーク通信にカーネルをバイパスさせるという私たちの決定は、根本的な修正の一例です。\n根本的な修正を特定できれば、前の章で説明した設計技法を使ってそれを実装することができます。\nしかし、残念ながら、根本的な修正ができない状況が発生することもあります。\nそこで、この章の核となる問題、つまり、既存のコードをより速く実行できるように再設計する方法について説明します。\nこれは最後の手段であるべきで、頻繁に起こることではありませんが、大きな違いを生むケースもあります。\n重要なのは、クリティカルパスを中心にコードを設計することです。\nまず、よくあるケースで、目的のタスクを実行するために実行しなければならない最小のコード量は何かと考えることから始めます。\n既存のコード構造は無視します。\n代わりに、最も一般的なケースで実行しなければならない最小量のコードであるクリティカルパスだけを実装した新しいメソッドを書くと想像してください。\n現在のコードは、おそらく特殊なケースでごちゃごちゃしていますが、この演習では無視します。\n現在のコードは、クリティカルパス上のいくつかのメソッドコールを通過しているかもしれません。\nその代わりに、関連するすべてのコードを1つのメソッドに入れることができたと想像してください。\nクリティカルパスに必要なデータだけを考え、クリティカルパスに最も適したデータ構造を想定してください。\n例えば、複数の変数を1つの値にまとめることが理にかなっている場合もあります。\nクリティカルパスのために実行しなければならないコードを最小にするために、システムを完全に再設計できたとする。このコードを \"理想的なもの \"と呼ぶことにしましょう。\n理想的なコードは、おそらく既存のクラス構造と衝突し、実用的でないかもしれませんが、これは良い目標を提供します：これは、コードがこれまでになり得る最も単純で最も速いことを表します。\n次のステップは、きれいな構造を保ちながら、できるだけ理想に近い新しい設計を探すことです。本書の前の章で出てきた設計のアイデアをすべて適用することができますが、理想的なコードを（ほとんど）そのまま維持するという制約が加わります。\n例えば、ハッシュテーブルを参照するようなコードであれば、汎用のハッシュテーブルクラスへのメソッドコールを追加してもかまいません。\n私の経験では、クリーンでシンプルでありながら、理想に非常に近い設計を見つけることはほとんど可能です。\nこのプロセスで最も重要なことの1つは、クリティカルパスから特殊なケースを取り除くことです。\nコードが遅いのは、様々な状況を処理しなければならないからです。\nコードが遅くなるのは、様々な状況を処理しなければならないからで、コードは全ての異なるケースの処理を単純化するように構造化されます。\nそれぞれの特殊なケースは、余分な条件文やメソッド呼び出しという形で、クリティカルパスに少しづつコードを追加していきます。\nこのような追加を行うたびに、コードは少しづつ遅くなっていきます。\nパフォーマンス向上のために再設計する場合は、チェックしなければならない特殊なケースの数を最小限にするようにしましょう。理想的なのは、冒頭にひとつの if 文を置き、ひとつのテストによってすべての特殊なケースを検出することです。通常の場合、この1つのテストを行うだけで、その後、特殊なケースのテストを追加することなくクリティカルパスを実行することができます。\n最初のテストが失敗した場合（つまり、特殊なケースが発生した場合）、コードはクリティカルパスから別の場所に分岐することができます。\nをクリティカルパスから切り離し、処理することができます。\n特殊なケースでは性能はそれほど重要ではないので、特殊なケースのコードは性能よりも単純さを重視して構成することができます。\nのコードを単純化することができます。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-08",
      "body_markdown": "## 21 重要なことを決める \n\n優れたソフトウェア設計の最も重要な要素の1つは、重要なものと重要でないものを分けることです。\n重要なものを中心にソフトウェアシステムを構成しましょう。\nあまり重要でないものについては、システムの他の部分に与える影響を最小限にするようにします。重要なものは強調し、より明白にし、重要でないものはできるだけ隠す。\n前章までの考え方の多くは、「重要なものとそうでないものを分ける」という考え方が根底にあります。\n例えば、抽象化されたものを設計するとき、私たちはこのようなことを行っています。\nモジュールのインターフェイスは、そのモジュールのユーザーにとって重要なものを反映します。モジュールのユーザーにとって重要でないものは、目立たないように実装に隠されるべきです。\n変数名を決めるときの目標は、その変数に関する最も重要な情報を伝える言葉をいくつか選び、それを名前に使用することです。\nもしモジュールのパフォーマンスが本当に重要なら、モジュールの設計はパフォーマンス目標を達成するために構成されるべきです。セクション 20.4 の例では、これはパフォーマンスが重要なパスができるだけ少ないメソッドコールと特殊ケースチェックを持ち、かつクリーンでシンプルで明白であるような設計を見つけることを意味します。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-08",
      "body_markdown": "## 21.1 何が重要かを決めるには？\n\n重要なことは、20.4節の性能のように、システムの外部制約として課されることもあります。\nより多くの場合、何が重要かを決定するのは設計者次第です。外部制約がある場合でも、設計者はその制約を達成するために何が最も重要かを考えなければなりません。\n何が重要かを決定するためには、ある問題を解決することによって他の多くの問題も解決できる、あるいは、ある情報を知ることによって他の多くのことを容易に理解できる、といった「レバレッジ」を探すことである。\n例えば、6.2節のテキストの保存方法の議論では、文字の範囲を挿入したり削除したりするための汎用的なインターフェイスは、多くの問題を解決するために使用することができたが、バックスペースなどの特殊な方法は、1つの問題しか解決することができなかった。\n汎用的なインターフェイスは、より大きな力を発揮する。\nテキストクラスのインターフェイスのレベルでは、バックスペースキーに対応してインターフェイスが呼び出されるかどうかは重要ではなく、本当に重要なのはテキストを削除する必要があるかどうかということだったのです。\nある変数や構造体の不変量がわかれば、さまざまな状況下でその変数や構造体がどのように振る舞うかを予測することができる。\n複数の選択肢から選ぶことができれば、何が最も重要かを判断しやすくなる。\n例えば、変数名を決めるときは、その変数に関連する言葉を頭の中でリストアップし、その中から最も情報量の多い言葉をいくつか選びます。\nその言葉を変数名とする。これは、「2回設計する」という原則の一例です。\n特に経験の少ない若い開発者にとっては、どれが一番重要なのかがわからないこともあります。そんなときは、「私はこれが一番大事だと思う」と仮説を立てることをお勧めします。\nそして、その仮説にコミットし、その前提でシステムを構築し、その結果を見ることです。仮説が正しかったら、なぜ正しかったのか、今後に活かせるヒントは何だったのかを考えてみてください。\n仮説が間違っていたとしても、それはそれでOKです。なぜ間違ってしまったのか、この選択を避けるために使える手がかりはなかったのか、考えてみてください。\nいずれにせよ、この経験から学び、徐々に良い選択ができるようになるはずです。",
      "body_updated_at": "2022-09-08"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-08",
      "body_markdown": "## 21.2 重要なものは最小限にする \n\n可能な限り問題を少なくすることで、システムをよりシンプルにすることができます。\n例えば、オブジェクトを構築するために指定しなければならないパラメータの数を最小限にしたり、最も一般的な使用方法を反映したデフォルト値を提供するようにします。\n重要なものについては、それが重要である場所の数を最小限にするようにします。\nモジュール内に隠されている情報は、そのモジュールの外のコードには重要ではありません。\n例外がシステムの低レベルで完全に処理できる場合、システムの残りの部分では重要ではありません。\nもし、ある設定パラメータがシステムの動作に基づいて自動的に計算されるなら（管理者が手動で選択するために公開するのではなく）、それはもはや管理者にとって重要ではありません。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-08",
      "body_markdown": "## 21.3 重要なことを強調する方法 \n\n重要な事柄を特定したら、設計の中でそれを強調する必要があります。\nインターフェイスのドキュメントや名前、よく使われるメソッドのパラメータなど、重要なものは目につきやすい場所に表示されるべきです。\nもうひとつは「繰り返し」です。重要なアイデアを何度も何度も登場させます。\n3つ目の方法は、中心性を強調することです。\n最も重要なものは、システムの中心部に置かれるべきで、そこで周囲のものの構造を決定する。\n例えば、OSのデバイスドライバのインタフェースは、何百、何千というドライバがこれに依存するため、中心的なアイデアとなる。\nもちろん、逆もまた真なりで、あるアイデアが見られる可能性が高い場合、何度も繰り返し現れる場合、システムの構造に大きな影響を与える場合、そのアイデアは重要であると言えます。\n同様に、重要でないものは、強調されるべきではない。\nできるだけ隠すべきで、頻繁に出会うべきではなく、システムの構造に影響を及ぼすべきではない。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-08",
      "body_markdown": "## 21.4 間違い \n\n何が重要かを決めるとき、2種類の間違いを犯す可能性があります。\n最初の間違いは、あまりにも多くのものを重要視しすぎることです。\nこの場合、重要でないものが設計を乱雑にし、複雑さを増し、認知負荷を増加させます。\nその一例が、ほとんどの呼び出し元にとって無関係な引数を持つメソッドです。\nもうひとつの例は、26ページで説明したJavaのI/Oインターフェースです。バッファ付きI/OとバッファなしI/Oの区別がほとんど重要でないにもかかわらず、開発者はこの区別を意識しなければなりませんでした（開発者はほとんど常に \nバッファリングが必要であり、それを明示的に要求して時間を浪費することはない）。\n浅いクラスは、多くのことを重要視しすぎた結果であることが多いのです。\n2つ目の間違いは、何かが重要であることを認識しないことです。\nこの間違いは、重要な情報が隠されていたり、重要な機能が使えないために開発者が常に作り直さなければならないような状況を引き起こします。\nこのような間違いは、開発者の生産性を阻害し、未知の未知をもたらすことになります。"
    },
    {
      "author": "wooootack",
      "created_at": "2022-09-08",
      "body_markdown": "## 21.5 より広い視野で考える\n\n最も重要なことに集中するという考え方は、ソフトウェア設計以外の他の領域にも当てはまります。\n文書を読みやすくする最善の方法は、冒頭でいくつかの重要な概念を特定し、それを中心に文書の残りの部分を構成することです。\nまた、システムの詳細を説明する際には、全体的なコンセプトと結びつけて説明することが有効です。\n自分にとって最も重要なことをいくつか決め、できるだけ多くのエネルギーをそのことに費やすようにします。\n重要でないこと、やりがいのないことに時間を浪費しないことです。\nセンスがいい」という言葉は、大切なものとそうでないものを見分ける能力を表しています。\n良いセンスを持つことは、良いソフトウェア設計者であるための重要な要素です。"
    }
  ]
}